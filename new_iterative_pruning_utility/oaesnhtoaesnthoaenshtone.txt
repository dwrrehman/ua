
static nat execute_graph_starting_at(byte origin) {

	const nat n = array_size;
	array[0] = 0; 
	array[n] = 0; 

	byte ip = origin, last_mcal_op = 255, last_op = 0, mcal_path = 0;

	nat 	e = 0,  xw = 0, 
		pointer = 0,  er_count = 0, bout_length = 0,
		walk_ia_counter = 0, ERW_counter = 0, 
		SNL_counter = 0,   mcal_index = 0,
	    	OER_er_at = 0,  OER_counter = 0, 
		BDL_er_at = 0,  BDL_counter = 0, 
		BDL2_er_at = 0,  BDL2_counter = 0, 
		R0I_counter = 0, H0_counter = 0, 
		H1_counter = 0, H2_counter = 0, H3_counter = 0,
		RMV_counter = 0, RMV_value = 0, CSM_counter = 0;


	nat did_ier_at = (nat)~0;



	for (; e < execution_limit; e++) {

		if (e == expansion_check_timestep2) { 
			for (byte i = 0; i < 5; i++) {
				if (array[i] < required_s0_increments) return PM_f1e; 
			}
		}

		if (e == expansion_check_timestep)  { 
			if (er_count < required_er_count) return PM_erc; 
		}
		
		const byte I = ip * 4, op = graph[I];

		// printf("op = %hhu\n", op);

		if (op == one) {
			if (pointer == n) return PM_fea; 
			if (not array[pointer]) return PM_ns0; 

			if (last_mcal_op == one)  H0_counter = 0;
			if (last_mcal_op == five) R0I_counter = 0;

			bout_length++;
			pointer++;

			if (pointer > xw and pointer < n) { 
				xw = pointer; 
				array[pointer] = 0; 
			}
		}

		else if (op == five) {
			if (last_mcal_op != three) return PM_pco; 
			if (not pointer) return PM_zr5; 
			
			if (	pointer == OER_er_at or 
				pointer == OER_er_at + 1) OER_counter++;
			else { OER_er_at = pointer; OER_counter = 0; }
			if (OER_counter >= max_acceptable_er_repetions) return PM_oer; 

			if (BDL_er_at and pointer == BDL_er_at - 1) { BDL_counter++; BDL_er_at--; }
			else { BDL_er_at = pointer; BDL_counter = 0; }
			if (BDL_counter >= max_acceptable_bdl_er_repetions) return PM_bdl; 

			if (BDL2_er_at > 1 and pointer == BDL2_er_at - 2) { BDL2_counter++; BDL2_er_at -= 2; }
			else { BDL2_er_at = pointer; BDL2_counter = 0; }
			if (BDL2_counter >= max_acceptable_bdl_er_repetions) return PM_bdl2; 

			CSM_counter = 0;
			RMV_value = (nat) -1;
			RMV_counter = 0;
			for (nat i = 0; i < xw; i++) {
				if (array[i] < 6) CSM_counter++; else CSM_counter = 0;
				if (CSM_counter > max_acceptable_consecutive_small_modnats) return PM_csm; 
				if (array[i] == RMV_value) RMV_counter++; else { RMV_value = array[i]; RMV_counter = 0; }
				if (RMV_counter >= max_acceptable_modnat_repetions) return PM_rmv; 
			}

			if (walk_ia_counter == 1) {
				ERW_counter++;
				if (ERW_counter == 100) {					
					return PM_erw; //TODO: make this not a literal!
				}
			} else ERW_counter = 0;

			did_ier_at = pointer;
			walk_ia_counter = 0;
			er_count++;
			pointer = 0;
		}

		else if (op == two) {
			if (array[n] >= 65535) return PM_snm; 

			
			if (last_op == six) SNL_counter++; 
			else if (last_op != two) SNL_counter = 0;
			if (SNL_counter == max_acceptable_sn_loop_iterations) return PM_snl;

			array[n]++;
		}
		else if (op == six) {  
			if (not array[n]) return PM_zr6; 

			if (last_op == two) SNL_counter++; 
			else SNL_counter = 0;
			if (SNL_counter == max_acceptable_sn_loop_iterations) return PM_snl;

			array[n] = 0;
		}
		else if (op == three) {
			if (last_mcal_op == three) return PM_ndi; 

			if (last_mcal_op == five) {
				R0I_counter++; 
				if (R0I_counter >= max_acceptable_consecutive_s0_incr) return PM_r0i; 
			}

			if (last_mcal_op == one) {
				H0_counter++;
				if (H0_counter >= max_acceptable_consecutive_h0_bouts) return PM_h0; 
			}

			if (bout_length == 1) {
				H1_counter++;
				if (H1_counter >= max_acceptable_consecutive_h1_bouts) return PM_h1; 
			} else H1_counter = 0;

			if (bout_length == 2) {
				H2_counter++;
				if (H2_counter >= max_acceptable_consecutive_h2_bouts) return PM_h2; 
			} else H2_counter = 0;

			if (bout_length == 3) {
				H3_counter++;
				if (H3_counter >= max_acceptable_consecutive_h3_bouts) return PM_h3; 
			} else H3_counter = 0;

			if (did_ier_at != (nat) ~0) {
				if (pointer >= did_ier_at) return PM_per;
				did_ier_at = (nat) ~0;
			}

			bout_length = 0;
			walk_ia_counter++;

			if (array[pointer] >= 65535) return PM_mm; 
			array[pointer]++;
		}

		if (op == three or op == one or op == five) { 
			last_mcal_op = op; mcal_index++; 

			memmove(history, history + 1, sizeof(nat) * 99);
			history[99] = op;
		}
		last_op = op;

		if (mcal_index == 1  and last_mcal_op != three) goto prune_via_mcal; // return PM_mcal; 
		if (mcal_index == 2  and last_mcal_op != one) 	goto prune_via_mcal; // return PM_mcal;
		if (mcal_index == 3  and last_mcal_op != three) goto prune_via_mcal; // return PM_mcal;
		if (mcal_index == 4  and last_mcal_op != five) 	goto prune_via_mcal; // return PM_mcal;
		if (mcal_index == 5  and last_mcal_op != three) goto prune_via_mcal; // return PM_mcal;
		if (mcal_index == 6  and last_mcal_op != one) 	goto prune_via_mcal; // return PM_mcal;

		if (mcal_index == 7) {
			if (last_mcal_op == five) goto prune_via_mcal; // return PM_mcal;
			mcal_path = last_mcal_op == three ? 1 : 2;
		}

		if (mcal_index == 8 and mcal_path == 1 and last_mcal_op != one)  	goto prune_via_mcal; // return PM_mcal;
		if (mcal_index == 8 and mcal_path == 2 and last_mcal_op != three)  	goto prune_via_mcal; // return PM_mcal;

		if (mcal_index == 9 and mcal_path == 1 and last_mcal_op != three)  	goto prune_via_mcal; // return PM_mcal;
		if (mcal_index == 9 and mcal_path == 2 and last_mcal_op != five)  	goto prune_via_mcal; // return PM_mcal;

		if (mcal_index == 10 and mcal_path == 1 and last_mcal_op != five)  	goto prune_via_mcal; // return PM_mcal;




		byte state = 0;
		if (array[n] < array[pointer]) state = 1;
		if (array[n] > array[pointer]) state = 2;
		if (array[n] == array[pointer]) state = 3;
		
		ip = graph[I + state];

	}


	return z_is_good;



}













static nat execute_graph(void) {
	nat pm = 0;
	for (byte o = 0; o < operation_count; o++) {
		if (graph[4 * o] != three) continue;
		pm = execute_graph_starting_at(o);   
		if (not pm) return z_is_good;
	}
	return pm;
}

static nat fea_execute_graph_starting_at(byte origin) {

	const nat n = 5;
	array[n] = 0; 
	array[0] = 0; 

	byte ip = origin, last_mcal_op = 0;
	nat pointer = 0, e = 0, xw = 0;

	for (; e < fea_execution_limit; e++) {

		const byte I = ip * 4, op = graph[I];

		if (op == one) {
			if (pointer == n) return PM_fea;
			if (not array[pointer]) return PM_ns0;
			pointer++;

			if (pointer > xw and pointer < n) { 
				xw = pointer; 
				array[pointer] = 0; 
			}
		}

		else if (op == five) {
			if (last_mcal_op != three) return PM_pco;
			if (not pointer) return PM_zr5;
			pointer = 0;
		}

		else if (op == two) { array[n]++; }
		else if (op == six) {  
			if (not array[n]) return PM_zr6;
			array[n] = 0;   
		}

		else if (op == three) {
			if (last_mcal_op == three) return PM_ndi;
			array[pointer]++;
		}

		if (op == three or op == one or op == five) last_mcal_op = op;

		byte state = 0;
		if (array[n] < array[pointer]) state = 1;
		if (array[n] > array[pointer]) state = 2;
		if (array[n] == array[pointer]) state = 3;
		ip = graph[I + state];
	}
	return z_is_good; 
}

static nat fea_execute_graph(void) {
	nat pm = 0;
	for (byte o = 0; o < operation_count; o++) {
		if (graph[4 * o] != three) continue;
		pm = fea_execute_graph_starting_at(o);
		if (not pm) return z_is_good;
	}
	return pm;
}