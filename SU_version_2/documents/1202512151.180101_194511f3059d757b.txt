1202512151.180020 

minimal data transformation that needs to happen for the PAS SU system:



	
PAS
	0291598240173938725983512




z-value:

	01151021273637474241054610001556













moduli:

	817254871283618747517838



	
PAS (nf array):

	002000000000000000000000











______________________________________________________

	       DOL      -------> moduli[]

		|	
		|	
		|	
		v

 	   PAS_decoder[]

	  PAS[]   -->   ZV (printing out in append_to_file)


______________________________________________________














job partitioning:
______________________________________________________



	
	only requires doing full   var-mod     nf algorithm    on top L digits  of PAS


		L = some small number that still gets us a reasonable number of jobs to process, for good parelelism




		





after we just pulled the job from the queue:
______________________________________________________


	1. like before, we OR the job data into the top MSB bits of the NF array / PAS

	2. the NF algortihm does not care still about what the bits mean, we dont need to decode it yet
				IT JUST CARES ABOUT THE MOD  ARRAY. that should be in place, 
					as constant data, that we can  access here. 

	3. at init:  of nf array, we need to decode the PAS array, into its meaning, in  SOMEEEE WAY 

		



			






















#define dol   ((one << 0) | (two << 4) | (five << 8))



/* const byte pas_pa = pa_map[pa] */
const byte value = ((decode[pas_pa] >> (nfarray[pas_pa] << 2)) & 0xf;



pas_pa = 0  MEANS    opi0.g
pas_pa = 1  MEANS    opi0.e
pas_pa = 2  MEANS    opi1.g
pas_pa = 3  MEANS    opi1.e
pas_pa = 4  MEANS    opi2.l

...

pas_pa = 22   MEANS   addr8.opi4.e




/*   DOL = {  1, 2, 5, 6,  }    */





0123456789ABCDEFGHIJKLM


--------------------
	PA_MAP:
--------------------
ad | opi  <   >   =
--------------------
 0 | 0 |  /   0   1 
--------------------
 1 | 1 |  /   2   3 
--------------------
 2 | 2 |  4   5   6
--------------------
 3 | 3 |  7   8   9
--------------------
 4 | 4 |  A   /   B
--------------------
 5 | 0 |  C   D   E
--------------------
 6 | 1 |  F   G   H
--------------------
 7 | 3 |  I   J   K
--------------------
 8 | 4 |  L   /   M
--------------------

23 digits, aka  23 nat's   each nat encodes up to 16 possible address



opi0:
	pas[pa=0] = 0    :  MEANS     address 0  --(g)-->  address 2   


	// (NOTE: THIS ARRAY OF NATS SHOULD BE AUTOGENERATED AS WELL!!! BASED ON THE GIVEN DOL,  
			USING ANOTHER C PROGRAM!!!!)

static const nat decode[] = {

                                                   
/* paspa 0 */	{   

	0 out [ns0],   
	1 out [sci],   
	2 in,   
	3 out [pco],  
	4 in,   
	5 out  [ns0],   
	6 





/* paspa 1 */	{3, 5, 6, 7, 8}
/* paspa 2 */	{3, 5, 6, 7, 8}
/* paspa 3 */	{3, 5, 6, 7, 8}
/* paspa 4 */	{}
/* paspa 2 */	{}
/* paspa 2 */	{}

	...

/* paspa 21 */	{}
/* paspa 22 */	{}


};












less than- modfication to the RDO pm:  mapping into using PASPA's


	
for each opi:
	//            l     g      e
	[opi] ==> { 3,11,   5,8,   7,10, } 
	//          A,B,    A,B,   A,B,

	if (pairs_greater(l)) prune    //    if (pas[3] > pas[11]) prune
	if (pairs_equal(l) and pairs_greater(g)) prune
	if (pairs_equal(l) and pairs_equal(g) and pairs_greater(e)) prune

	if (pairs_equal(l) and pairs_equal(g) and pairs_equal(e)) prune






here, we are leveraging the fact that   

		comparison between   A and B    happening on the level of PAS values, ie, NF array values, 


			IS VALID     BECAUSEEEEEE 



			of the fact that we are comparing two     .g's     or .l's      or .e's, 


				ANDDDD we know that the opi's   ARE ALSOOO the same, by definition, of the pair array values. 


					thus, we cannn meaningfullly compare PAS values  in this way,  i think 











2-Loop GA checks:
________________________________________



	here, we use the crazy fact that     we dont actaullyyyy need to chain execution edges through the graph in order to recognize a loop.


		because of the fact that we know the DOL,  we know precisely   every single way that a given loop could appear in the PAS array. 

				we just need to check the right PASPA's     against the right  PAS values, 


					and then if we see that those PASPA's have those values at those positions, 

					then we know to prune it.   simple as that.









all unconditional    (5u1, 6u2, 3u5, 3u1) checks   

	would also be turned into just PASPA related checks only, 
		no execution required, and no pa_map use required. 


		



thus all of GA, would just look like this:      (where pas[] is the nfarray of course)




    if (pas[3] > pas[11]) prune

    if (pas[4] == 5) prune

    if (pas[5] < pas[13]) prune

	...

    if (pas[0] == 4 and pas[2] == 7) prune

	...




there would be a ton of these kinds of checks,
	and they are HIGHLY specific to what our current DOL is. 

	when we change our DOL, we need to completely change these checks, 


			orrrrr we need to have some compiletime computation    figure out what the updated version of these checks would be, for the new DOL setting. 


	


			lets write a seperate C program to generate    essentially    ALL OF GA!!!

					 (sans UO...) 




						(uo works completely differently, i havent quite figured out that part yet lol)







iter revised (rev 2):

	after we just pulled the job from the queue:

______________________________________________________
	



	1. like before, we OR the job data into the top MSB bits of the NF array / PAS


	2. the NF algortihm does not care still about what the bits mean, we dont need to decode it yet
				IT JUST CARES ABOUT THE MOD  ARRAY. that should be in place, 
					as constant data, that we can  access here. 


	3. at init:  of nf array, we then execute all of GA  (without UO, that part is still uncertain so far)

				we just paste  the generated GA paspa'tized   checks  that were output 
									from our CT generated GA program

				this paspa GA includes 2-loops, uncond checks, and less-than-RDO.



	4. once we have survived GA, then we execute the graph. 
		here, it makes sense to finally use the   decode[]  array    and the pas[]    to construct a zv?

			or at least use those two arrays inside  EXG  to run the graph properly 


		
	5. once we got out of EXG,  (note, "at" values are always paspa's!!!!)

		then we call append_to_file()




	6. this append_to_file() function finallyyyyy converts the    PAS[]  values, using the decode[]   array 

					INTO AN ACTUAL Z-VALUE!


					that we can then write to a file, 

							and easily read with any other utility 
							that knows how to operate on zv's of that D-space. 



	7. pull next job, ie, goto loop  or something, to continue the nf
		








1202512151.201513

STORING A ZV  -   data structure:
_________________________________________________


	lets use an array of uint16_t's!!!    one per op



		ie, each operation (and its trich outcomes/addresses)    is a single 16-bit number, 




			and a graph is just a memory array of these uint16's!


				this is a fairly dense representation, and simple to implement! 


		this is also easily useable for execution, and also easily  written to a file, as well

			






OH! anddd we'll do this full stored-translation to the array of u16's    PRIOR   to EXG!

	ie, we convert back to zv space before both   execute_graph()   and append_to_file()


	we only to use the decode array once   during this process, thus. 


		

































