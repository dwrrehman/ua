    1|       |// 202406086.154106: dwrr
    2|       |//   the binary space partitioning  srnfgpr   version of the search utiltiy. 
    3|       |//    designed to optimally split up the jobs in the search space   amoung a set of threads, 
    4|       |//    while splitting up jobs the least, and incurring the least amount 
    5|       |//     of sychronization between threads. 
    6|       |
    7|       |// old 202403041.192520: by dwrr         
    8|       |//      the prthead  cpu-parellelized version of the srnfgpr.
    9|       |//
   10|       |#include <time.h>
   11|       |#include <string.h>
   12|       |#include <unistd.h>
   13|       |#include <fcntl.h>
   14|       |#include <iso646.h>
   15|       |#include <stdint.h>
   16|       |#include <stdio.h>
   17|       |#include <stdlib.h>
   18|       |#include <stdatomic.h>
   19|       |#include <sys/stat.h>
   20|       |#include <sys/time.h>
   21|       |#include <sys/types.h>
   22|       |#include <pthread.h>
   23|       |
   24|       |typedef uint8_t byte;
   25|       |typedef uint64_t nat;
   26|       |typedef uint32_t u32;
   27|       |typedef uint16_t u16;
   28|       |
   29|       |static const byte D = 1;        // the duplication count (operation_count = 5 + D)
   30|       |static const byte R = 0;   	// which partial graph we are using. (1 means 63R, 0 means 36R.)
   31|       |
   32|       |static const nat range_update_frequency = 0;
   33|       |static const nat minimum_split_size = 6;
   34|       |static const nat thread_count = 6;
   35|       |static const nat display_rate = 0;
   36|       |
   37|       |enum operations { one, two, three, five, six };
   38|       |
   39|       |enum pruning_metrics {
   40|       |	z_is_good, pm_ga, 
   41|       |	pm_fea, pm_ns0, 
   42|       |
   43|       |	pm_pco, pm_zr5, 
   44|       |	pm_zr6, pm_ndi, 
   45|       |
   46|       |	pm_oer, pm_r0i, 
   47|       |	pm_h0, pm_f1e, 
   48|       |
   49|       |	pm_erc, pm_rmv, 
   50|       |	pm_ot, pm_csm, 
   51|       |
   52|       |	pm_mm, pm_snm, 
   53|       |	pm_bdl, pm_bdl2, 
   54|       |
   55|       |	pm_erw, pm_mcal, 
   56|       |	pm_snl, pm_h1, 
   57|       |
   58|       |	pm_h2, pm_h3, 
   59|       |	pm_per, pmf_fea, 
   60|       |
   61|       |	pmf_ns0, pmf_pco,
   62|       |	pmf_zr5, pmf_zr6, 
   63|       |
   64|       |	pmf_ndi, pmf_per, 
   65|       |	pmf_mcal,
   66|       |
   67|       |	pm_count
   68|       |};
   69|       |
   70|       |static const char* pm_spelling[pm_count] = {
   71|       |	"z_is_good", "pm_ga", 
   72|       |	"pm_fea", "pm_ns0", 
   73|       |	
   74|       |	"pm_pco", "pm_zr5", 
   75|       |	"pm_zr6", "pm_ndi", 
   76|       |
   77|       |	"pm_oer", "pm_r0i", 
   78|       |	"pm_h0", "pm_f1e", 
   79|       |
   80|       |	"pm_erc", "pm_rmv", 
   81|       |	"pm_ot", "pm_csm", 
   82|       |
   83|       |	"pm_mm", "pm_snm", 
   84|       |	"pm_bdl", "pm_bdl2", 
   85|       |
   86|       |	"pm_erw", "pm_mcal", 
   87|       |	"pm_snl", "pm_h1", 
   88|       |
   89|       |	"pm_h2", "pm_h3", 
   90|       |	"pm_per", "pmf_fea", 
   91|       |
   92|       |	"pmf_ns0", "pmf_pco",
   93|       |	"pmf_zr5", "pmf_zr6", 
   94|       |
   95|       |	"pmf_ndi", "pmf_per", 
   96|       |	"pmf_mcal",
   97|       |
   98|       |};
   99|       |
  100|       |static const byte _ = 0;
  101|       |
  102|       |static const byte _63R[5 * 4] = {
  103|       |	0,  1, 4, _,      //        3
  104|       |	1,  0, _, _,      //     6  7 
  105|       |	2,  0, _, _,      //    10 11
  106|       |	3,  _, _, _,      // 13 14 15
  107|       |	4,  2, 0, _,      //       19
  108|       |};
  109|       |
  110|       |#define _63R_hole_count 9
  111|       |static const byte _63R_hole_positions[_63R_hole_count] = {3, 6, 7, 10, 11, 13, 14, 15, 19};
  112|       |
  113|       |static const byte _36R[5 * 4] = {
  114|       |	0,  1, 2, _,      //        3
  115|       |	1,  0, _, _,      //     6  7 
  116|       |	2,  _, 4, _,      //  9    11
  117|       |	3,  _, _, _,      // 13 14 15
  118|       |	4,  0, 0, _,      //       19
  119|       |};
  120|       |
  121|       |#define _36R_hole_count 9
  122|       |static const byte _36R_hole_positions[_36R_hole_count] = {3, 6, 7, 9, 11, 13, 14, 15, 19};
  123|       |
  124|       |static const byte initial = R ? _63R_hole_count : _36R_hole_count;
  125|       |
  126|       |static const byte operation_count = 5 + D;
  127|       |static const byte graph_count = 4 * operation_count;
  128|       |
  129|       |static const byte hole_count = initial + 4 * D;
  130|       |
  131|       |static const nat fea_execution_limit = 5000;
  132|       |static const nat execution_limit = 10000000000;
  133|       |static const nat array_size = 100000;
  134|       |
  135|       |static const byte max_er_repetions = 50;
  136|       |static const byte max_erw_count = 100;
  137|       |static const byte max_modnat_repetions = 15;
  138|       |static const byte max_consecutive_s0_incr = 30;
  139|       |static const byte max_consecutive_small_modnats = 200;
  140|       |static const byte max_bdl_er_repetions = 25;
  141|       |static const byte max_sn_loop_iterations = 100 * 2;
  142|       |static const byte max_consecutive_h0_bouts = 10;
  143|       |static const byte max_consecutive_h2_bouts = 30;
  144|       |static const byte max_consecutive_h3_bouts = 30;
  145|       |
  146|       |// static const byte max_consecutive_h1_bouts = 30;
  147|       |
  148|       |static const nat expansion_check_timestep = 5000;
  149|       |static const nat required_er_count = 25;
  150|       |
  151|       |static const nat expansion_check_timestep2 = 10000;
  152|       |static const nat required_s0_increments = 5;
  153|       |
  154|       |// runtime constants:
  155|       |static nat space_size = 0;
  156|       |static byte* positions = NULL; 
  157|       |static pthread_t* threads = NULL; 
  158|       |
  159|       |
  160|       |// runtime variables:
  161|       |static _Atomic nat* global_range_begin = NULL;
  162|       |static _Atomic nat* global_range_end = NULL;
  163|       |static pthread_mutex_t mutex;
  164|       |
  165|       |
  166|      0|static void print_graph_raw(byte* graph) { for (byte i = 0; i < graph_count; i++) printf("%hhu", graph[i]); puts(""); }
  167|       |
  168|      0|static void get_graphs_z_value(char string[64], byte* graph) {
  169|      0|	for (byte i = 0; i < graph_count; i++) string[i] = (char) graph[i] + '0';
  170|      0|	string[graph_count] = 0;
  171|      0|}
  172|       |
  173|  11.1k|static void get_datetime(char datetime[32]) {
  174|  11.1k|	struct timeval tv;
  175|  11.1k|	gettimeofday(&tv, NULL);
  176|  11.1k|	struct tm* tm_info = localtime(&tv.tv_sec);
  177|  11.1k|	strftime(datetime, 32, "1%Y%m%d%u.%H%M%S", tm_info);
  178|  11.1k|}
  179|       |
  180|  2.85M|static nat execute_graph_starting_at(byte origin, byte* graph, nat* array) {
  181|       |
  182|  2.85M|	const nat n = array_size;
  183|  2.85M|	array[0] = 0; 
  184|  2.85M|	array[n] = 0;
  185|       |
  186|  2.85M|	nat 	e = 0,  xw = 0,  pointer = 0,  
  187|  2.85M|		er_count = 0, 
  188|  2.85M|		mcal_index = 0, 
  189|  2.85M|		bout_length = 0, 
  190|  2.85M|		walk_ia_counter = 0, 
  191|  2.85M|		RMV_value = 0, 
  192|  2.85M|		OER_er_at = 0,
  193|  2.85M|		BDL_er_at = 0,
  194|  2.85M|		BDL2_er_at = 0;
  195|       |
  196|  2.85M|	byte 	mcal_path = 0,
  197|  2.85M|		ERW_counter = 0, SNL_counter = 0,  OER_counter = 0,  BDL_counter = 0, 
  198|  2.85M|		BDL2_counter = 0,  R0I_counter = 0, 
  199|  2.85M|		H0_counter = 0, H2_counter = 0, H3_counter = 0, 
  200|  2.85M|		RMV_counter = 0, CSM_counter = 0;
  201|       |
  202|  2.85M|	byte ip = origin;
  203|  2.85M|	byte last_op = 255, last_mcal_op = 255;
  204|  2.85M|	nat did_ier_at = (nat)~0;
  205|       |
  206|  2.43G|	for (; e < execution_limit; e++) {
  207|       |
  208|  2.43G|		if (e == expansion_check_timestep2) { 
  209|    441|			for (byte i = 0; i < 5; i++) {
  210|    411|				if (array[i] < required_s0_increments) return pm_f1e; 
  211|    411|			}
  212|    117|		}
  213|       |
  214|  2.43G|		if (e == expansion_check_timestep)  { 
  215|   721k|			if (er_count < required_er_count) return pm_erc; 
  216|   440k|		}
  217|       |		
  218|  2.43G|		const byte I = ip * 4, op = graph[I];
  219|       |
  220|  2.43G|		if (op == one) {
  221|  12.6M|			if (pointer == n) return pm_fea; 
  222|  12.6M|			if (not array[pointer]) return pm_ns0; 
  223|       |
  224|  12.6M|			if (last_mcal_op == one)  H0_counter = 0;
  225|  12.6M|			if (last_mcal_op == five) R0I_counter = 0;
  226|       |
  227|  12.6M|			bout_length++;
  228|  12.6M|			pointer++;
  229|       |
  230|  12.6M|			if (pointer > xw and pointer < n) { 
  231|  3.06M|				xw = pointer; 
  232|  3.06M|				array[pointer] = 0; 
  233|  3.06M|			}
  234|  12.6M|		}
  235|       |
  236|  2.42G|		else if (op == five) {
  237|  1.93M|			if (last_mcal_op != three) return pm_pco; 
  238|  1.93M|			if (not pointer) return pm_zr5; 
  239|       |			
  240|  1.82M|			if (	pointer == OER_er_at or 
  241|  1.82M|				pointer == OER_er_at + 1) OER_counter++;
  242|   784k|			else { OER_er_at = pointer; OER_counter = 0; }
  243|  1.82M|			if (OER_counter >= max_er_repetions) return pm_oer; 
  244|       |
  245|  1.82M|			if (BDL_er_at and pointer == BDL_er_at - 1) { BDL_counter++; BDL_er_at--; }
  246|  1.51M|			else { BDL_er_at = pointer; BDL_counter = 0; }
  247|  1.82M|			if (BDL_counter >= max_bdl_er_repetions) return pm_bdl; 
  248|       |
  249|  1.82M|			if (BDL2_er_at > 1 and pointer == BDL2_er_at - 2) { BDL2_counter++; BDL2_er_at -= 2; }
  250|  1.78M|			else { BDL2_er_at = pointer; BDL2_counter = 0; }
  251|  1.82M|			if (BDL2_counter >= max_bdl_er_repetions) return pm_bdl2; 
  252|       |
  253|  1.82M|			CSM_counter = 0;
  254|  1.82M|			RMV_value = (nat) -1;
  255|  1.82M|			RMV_counter = 0;
  256|  15.9M|			for (nat i = 0; i < xw; i++) {
  257|  14.1M|				if (array[i] < 6) CSM_counter++; else CSM_counter = 0;
  258|  14.1M|				if (CSM_counter > max_consecutive_small_modnats) return pm_csm; 
  259|  14.1M|				if (array[i] == RMV_value) RMV_counter++; else { RMV_value = array[i]; RMV_counter = 0; }
  260|  14.1M|				if (RMV_counter >= max_modnat_repetions) return pm_rmv; 
  261|  14.1M|			}
  262|       |
  263|  1.80M|			if (walk_ia_counter == 1) {
  264|   212k|				ERW_counter++;
  265|   212k|				if (ERW_counter >= max_erw_count) return pm_erw;
  266|  1.59M|			} else ERW_counter = 0;
  267|       |
  268|  1.80M|			did_ier_at = pointer;
  269|  1.80M|			walk_ia_counter = 0;
  270|  1.80M|			er_count++;
  271|  1.80M|			pointer = 0;
  272|  1.80M|		}
  273|       |
  274|  2.78G|		else if (op == two) {
  275|  2.78G|			if (array[n] >= 65535) return pm_snm; 
  276|       |
  277|  2.78G|			if (last_op == six) SNL_counter++; 
  278|  2.60G|			else if (last_op != two) SNL_counter = 0;
  279|  2.78G|			if (SNL_counter >= max_sn_loop_iterations) return pm_snl;
  280|       |
  281|  2.78G|			array[n]++;
  282|  2.78G|		}
  283|  18.4E|		else if (op == six) {  
  284|   184M|			if (not array[n]) return pm_zr6; 
  285|       |
  286|   184M|			if (last_op == two) SNL_counter++; 
  287|   317k|			else SNL_counter = 0;
  288|   184M|			if (SNL_counter >= max_sn_loop_iterations) return pm_snl;
  289|       |
  290|   184M|			array[n] = 0;
  291|   184M|		}
  292|  18.4E|		else if (op == three) {
  293|  6.82M|			if (last_mcal_op == three) return pm_ndi; 
  294|       |
  295|  6.81M|			if (last_mcal_op == five) {
  296|  1.42M|				R0I_counter++; 
  297|  1.42M|				if (R0I_counter >= max_consecutive_s0_incr) return pm_r0i; 
  298|  1.42M|			}
  299|       |
  300|  6.79M|			if (last_mcal_op == one) {
  301|  2.55M|				H0_counter++;
  302|  2.55M|				if (H0_counter >= max_consecutive_h0_bouts) return pm_h0; 
  303|  2.55M|			}
  304|       |
  305|  6.74M|			if (bout_length == 2) {
  306|   375k|				H2_counter++;
  307|   375k|				if (H2_counter >= max_consecutive_h2_bouts) return pm_h2; 
  308|  6.36M|			} else H2_counter = 0;
  309|       |
  310|  6.74M|			if (bout_length == 3) {
  311|   136k|				H3_counter++;
  312|   136k|				if (H3_counter >= max_consecutive_h3_bouts) return pm_h3; 
  313|  6.60M|			} else H3_counter = 0;
  314|       |
  315|  6.74M|			if (did_ier_at != (nat) ~0) {
  316|  1.75M|				if (pointer >= did_ier_at) return pm_per;
  317|  1.74M|				did_ier_at = (nat) ~0;
  318|  1.74M|			}
  319|       |
  320|  6.73M|			bout_length = 0;
  321|  6.73M|			walk_ia_counter++;
  322|       |
  323|  6.73M|			if (array[pointer] >= 65535) return pm_mm; 
  324|  6.73M|			array[pointer]++;
  325|  6.73M|		}
  326|       |
  327|  2.97G|		if (op == three or op == one or op == five) { last_mcal_op = op; mcal_index++; }
  328|  2.43G|		last_op = op;
  329|       |
  330|  2.43G|		if (mcal_index == 1  and last_mcal_op != three) return pm_mcal;
  331|  2.43G|		if (mcal_index == 2  and last_mcal_op != one) 	return pm_mcal;
  332|  2.43G|		if (mcal_index == 3  and last_mcal_op != three) return pm_mcal;
  333|  2.43G|		if (mcal_index == 4  and last_mcal_op != five) 	return pm_mcal;
  334|  2.43G|		if (mcal_index == 5  and last_mcal_op != three) return pm_mcal;
  335|  2.43G|		if (mcal_index == 6  and last_mcal_op != one) 	return pm_mcal;
  336|       |
  337|  2.43G|		if (mcal_index == 7) {
  338|   264k|			if (last_mcal_op == five) return pm_mcal;
  339|   264k|			mcal_path = last_mcal_op == three ? 1 : 2;
  340|   264k|		}
  341|       |
  342|  2.43G|		if (mcal_index == 8 and mcal_path == 1 and last_mcal_op != one)  	return pm_mcal;
  343|  2.43G|		if (mcal_index == 8 and mcal_path == 2 and last_mcal_op != three)  	return pm_mcal;
  344|       |
  345|  2.43G|		if (mcal_index == 9 and mcal_path == 1 and last_mcal_op != three)  	return pm_mcal;
  346|  2.43G|		if (mcal_index == 9 and mcal_path == 2 and last_mcal_op != five)  	return pm_mcal;
  347|       |
  348|  2.43G|		if (mcal_index == 10 and mcal_path == 1 and last_mcal_op != five)  	return pm_mcal;
  349|       |
  350|  2.43G|		byte state = 0;
  351|  2.43G|		if (array[n] < array[pointer]) state = 1;
  352|  2.77G|		if (array[n] > array[pointer]) state = 2;
  353|  2.43G|		if (array[n] == array[pointer]) state = 3;
  354|       |		
  355|  2.43G|		ip = graph[I + state];
  356|  2.43G|	}
  357|  18.4E|	return z_is_good;
  358|  2.85M|}
  359|       |
  360|  2.64M|static nat execute_graph(byte* graph, nat* array, byte* origin) {
  361|  2.64M|	nat pm = 0;
  362|  18.4M|	for (byte o = 0; o < operation_count; o++) {
  363|  15.8M|		if (graph[4 * o] != three) continue;
  364|  2.85M|		pm = execute_graph_starting_at(o, graph, array);   
  365|  2.85M|		if (not pm) { *origin = o; return z_is_good; } 
  366|  2.85M|	}
  367|  2.64M|	return pm;
  368|  2.64M|}
  369|       |
  370|  93.2M|static nat fea_execute_graph_starting_at(byte origin, byte* graph, nat* array) {
  371|       |
  372|  93.2M|	const nat n = 5;
  373|  93.2M|	array[n] = 0; 
  374|  93.2M|	array[0] = 0; 
  375|  93.2M|	byte ip = origin, last_mcal_op = 255, mcal_path = 0;
  376|  93.2M|	nat pointer = 0, e = 0, xw = 0, mcal_index = 0;
  377|  93.2M|	nat did_ier_at = (nat)~0;
  378|       |
  379|  2.58G|	for (; e < fea_execution_limit; e++) {
  380|       |
  381|  2.58G|		const byte I = ip * 4, op = graph[I];
  382|       |
  383|  2.58G|		if (op == one) {
  384|   158M|			if (pointer == n) return pmf_fea;
  385|   158M|			if (not array[pointer]) return pmf_ns0;
  386|   154M|			pointer++;
  387|       |
  388|   154M|			if (pointer > xw and pointer < n) { 
  389|  59.0M|				xw = pointer; 
  390|  59.0M|				array[pointer] = 0; 
  391|  59.0M|			}
  392|   154M|		}
  393|       |
  394|  2.43G|		else if (op == five) {
  395|   111M|			if (last_mcal_op != three) return pmf_pco;
  396|   104M|			if (not pointer) return pmf_zr5;
  397|       |
  398|  53.1M|			did_ier_at = pointer;
  399|  53.1M|			pointer = 0;
  400|  53.1M|		}
  401|       |
  402|  3.36G|		else if (op == two) { array[n]++; }
  403|  18.4E|		else if (op == six) {  
  404|  2.26G|			if (not array[n]) return pmf_zr6;
  405|  2.22G|			array[n] = 0;   
  406|  2.22G|		}
  407|       |
  408|  18.4E|		else if (op == three) {
  409|   235M|			if (last_mcal_op == three) return pmf_ndi;
  410|       |
  411|   220M|			if (did_ier_at != (nat) ~0) {
  412|  65.1M|				if (pointer >= did_ier_at) return pmf_per;
  413|  65.0M|				did_ier_at = (nat) ~0;
  414|  65.0M|			}
  415|       |
  416|   220M|			array[pointer]++;
  417|   220M|		}
  418|       |
  419|  5.39G|		if (op == three or op == one or op == five) { last_mcal_op = op; mcal_index++; }
  420|       |
  421|  2.47G|		if (mcal_index == 1  and last_mcal_op != three) return pmf_mcal; 
  422|  5.19G|		if (mcal_index == 2  and last_mcal_op != one) 	return pmf_mcal;
  423|  2.47G|		if (mcal_index == 3  and last_mcal_op != three) return pmf_mcal;
  424|  2.47G|		if (mcal_index == 4  and last_mcal_op != five) 	return pmf_mcal;
  425|  2.45G|		if (mcal_index == 5  and last_mcal_op != three) return pmf_mcal;
  426|  2.44G|		if (mcal_index == 6  and last_mcal_op != one) 	return pmf_mcal;
  427|       |
  428|  2.44G|		if (mcal_index == 7) {
  429|  4.19M|			if (last_mcal_op == five) return pmf_mcal;
  430|  4.19M|			mcal_path = last_mcal_op == three ? 1 : 2;
  431|  4.19M|		}
  432|       |
  433|  2.44G|		if (mcal_index == 8 and mcal_path == 1 and last_mcal_op != one)  	return pmf_mcal;
  434|  2.44G|		if (mcal_index == 8 and mcal_path == 2 and last_mcal_op != three)  	return pmf_mcal;
  435|       |
  436|  2.44G|		if (mcal_index == 9 and mcal_path == 1 and last_mcal_op != three)  	return pmf_mcal;
  437|  2.44G|		if (mcal_index == 9 and mcal_path == 2 and last_mcal_op != five)  	return pmf_mcal;
  438|       |
  439|  2.44G|		if (mcal_index == 10 and mcal_path == 1 and last_mcal_op != five)  	return pmf_mcal;
  440|       |
  441|  2.44G|		byte state = 0;
  442|  2.44G|		if (array[n] < array[pointer]) state = 1;
  443|  3.37G|		if (array[n] > array[pointer]) state = 2;
  444|  2.44G|		if (array[n] == array[pointer]) state = 3;
  445|  2.44G|		ip = graph[I + state];
  446|  2.44G|	}
  447|  18.4E|	return z_is_good; 
  448|  93.2M|}
  449|       |
  450|  80.1M|static nat fea_execute_graph(byte* graph, nat* array) {
  451|  80.1M|	nat pm = 0;
  452|   496M|	for (byte o = 0; o < operation_count; o++) {
  453|   419M|		if (graph[4 * o] != three) continue;
  454|  81.6M|		pm = fea_execute_graph_starting_at(o, graph, array);
  455|  81.6M|		if (not pm) return z_is_good;
  456|  81.6M|	}
  457|  77.4M|	return pm;
  458|  80.1M|}
  459|       |
  460|      0|static void append_to_file(char* filename, size_t size, byte* graph, byte origin) {
  461|      0|	char dt[32] = {0};   get_datetime(dt);
  462|      0|	char z[64] = {0};    get_graphs_z_value(z, graph); 
  463|      0|	char o[16] = {0};    snprintf(o, sizeof o, "%hhu", origin);
  464|       |
  465|      0|	int flags = O_WRONLY | O_APPEND;
  466|      0|	mode_t permissions = 0;
  467|       |
  468|      0|try_open:;
  469|      0|	const int file = open(filename, flags, permissions);
  470|      0|	if (file < 0) {
  471|      0|		if (permissions) {
  472|      0|			perror("create openat file");
  473|      0|			printf("[%s]: [z=%s]: failed to create filename = \"%s\"\n", dt, z, filename);
  474|      0|			fflush(stdout);
  475|      0|			abort();
  476|      0|		}
  477|      0|		snprintf(filename, size, "%s_%08x%08x%08x%08x_z.txt", dt, 
  478|      0|			rand(), rand(), rand(), rand()
  479|      0|		);
  480|      0|		flags = O_CREAT | O_WRONLY | O_APPEND | O_EXCL;
  481|      0|		permissions = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
  482|      0|		goto try_open;
  483|      0|	}
  484|       |
  485|      0|	write(file, z, strlen(z));
  486|      0|	write(file, " ", 1);
  487|      0|	write(file, o, strlen(o));
  488|      0|	write(file, " ", 1);
  489|      0|	write(file, dt, strlen(dt));
  490|      0|	write(file, "\n", 1);
  491|      0|	close(file);
  492|       |
  493|      0|	printf("[%s]: write: %s z = %s to file \"%s\"\n",
  494|      0|		dt, permissions ? "created" : "wrote", z, filename
  495|      0|	);
  496|      0|}
  497|       |
  498|      6|static void* worker_thread(void* raw_argument) {
  499|       |
  500|      6|	char filename[4096] = {0};
  501|      6|	nat* pms = calloc(pm_count, sizeof(nat));
  502|      6|	nat* array = calloc(array_size + 1, sizeof(nat));
  503|      6|	void* raw_graph = calloc(1, graph_count + (8 - (graph_count % 8)) % 8);
  504|      6|	void* raw_end = calloc(1, graph_count   + (8 - (graph_count % 8)) % 8);
  505|      6|	byte* graph = raw_graph;
  506|      6|	byte* end = raw_end;
  507|      6|	nat* graph_64 = raw_graph;
  508|      6|	nat* end_64 = raw_end;
  509|      6|	memcpy(graph, R ? _63R : _36R, 20);
  510|      6|	memcpy(end, R ? _63R : _36R, 20);
  511|      6|	byte pointer = 0;
  512|      6|	nat publish_counter = 0;
  513|       |
  514|      6|	const nat thread_index = *(nat*) raw_argument;
  515|      6|	free(raw_argument);
  516|       |
  517|      6|	nat range_begin = atomic_load_explicit(global_range_begin + thread_index, memory_order_relaxed);
  518|      6|	nat range_end = atomic_load_explicit(global_range_end + thread_index, memory_order_relaxed);
  519|       |
  520|       |	//printf("worker_thread[%llu]: starting with job:  [range_begin=%llu, range_end=%llu]\n", thread_index, range_begin, range_end);
  521|       |	
  522|     63|next_job:;
  523|     63|	nat p = 1;
  524|    882|	for (nat i = 0; i < hole_count; i++) {
  525|    819|		graph[positions[i]] = (byte) ((range_begin / p) % (nat) (positions[i] & 3 ? operation_count : 5));
  526|    819|		p *= (nat) (positions[i] & 3 ? operation_count : 5);
  527|    819|	}
  528|       |
  529|     63|	p = 1;
  530|    882|	for (nat i = 0; i < hole_count; i++) {
  531|    819|		end[positions[i]] = (byte) ((range_end / p) % (nat) (positions[i] & 3 ? operation_count : 5));
  532|    819|		p *= (nat) (positions[i] & 3 ? operation_count : 5);
  533|    819|	}
  534|     63|	goto init;
  535|       |
  536|   186M|loop:	for (byte i = (operation_count & 1) + (operation_count >> 1); i--;) {
  537|   186M|		if (graph_64[i] < end_64[i]) goto process;
  538|   816k|		if (graph_64[i] > end_64[i]) break;
  539|   816k|	}
  540|       |
  541|  18.4E|done:
  542|       |	//printf("worker_thread[%llu]: finished with job! waiting for mutex...[%llu : %llu]\n", thread_index, range_begin, range_end);
  543|     63|	pthread_mutex_lock(&mutex);
  544|       |
  545|     63|	nat largest_remaining = 0, chosen_thread = 0;
  546|       |
  547|    441|	for (nat thread = 0; thread < thread_count; thread++) {
  548|    378|		const nat b = atomic_load_explicit(global_range_begin + thread, memory_order_relaxed);
  549|    378|		const nat e = atomic_load_explicit(global_range_end + thread, memory_order_relaxed);
  550|    378|		const nat size =  e >= b ? e - b : 0;
  551|    378|		if (size > largest_remaining) { largest_remaining = size; chosen_thread = thread; }
  552|    378|	}
  553|       |
  554|     63|	if (largest_remaining < minimum_split_size) {
  555|      6|		printf("worker_thread[%llu]: largest remaining (%llu) was less than minimum split size of %llu\n", thread_index, largest_remaining, minimum_split_size);
  556|      6|		pthread_mutex_unlock(&mutex);
  557|      6|		goto terminate_thread;
  558|      6|	}
  559|       |
  560|       |	//printf("worker_thread[%llu]: performing a split: using thread #%llu, which had a largest remaining of %llu\n", thread_index, chosen_thread, largest_remaining);
  561|       |	
  562|     57|	const nat subtract_off_amount = (largest_remaining >> 1);
  563|     57|	const nat job_ends_at = atomic_fetch_sub_explicit(global_range_end + chosen_thread, subtract_off_amount + 1, memory_order_relaxed);
  564|       |
  565|     57|	range_begin = job_ends_at - subtract_off_amount;
  566|     57|	range_end = job_ends_at;
  567|       |
  568|     57|	atomic_store_explicit(global_range_begin + thread_index, range_begin, memory_order_relaxed);
  569|     57|	atomic_store_explicit(global_range_end + thread_index, range_end, memory_order_relaxed);
  570|       |
  571|     57|	pthread_mutex_unlock(&mutex);
  572|       |
  573|       |	//printf("worker_thread[%llu]: performed a split, now processing this job:  [range_begin=%llu, range_end=%llu]\n", thread_index, range_begin, range_end);
  574|       |
  575|     57|	goto next_job;
  576|       |
  577|   185M|process:
  578|   185M|	if (graph[positions[pointer]] < (positions[pointer] & 3 ? operation_count - 1 : 4)) goto increment;
  579|  53.1M|	if (pointer < hole_count - 1) goto reset_;
  580|  18.4E|	goto done;
  581|       |
  582|  18.4E|increment:
  583|   152M|	graph[positions[pointer]]++;
  584|   152M|init:  	pointer = 0;
  585|       |
  586|   152M|	if (publish_counter >= range_update_frequency) {
  587|       |
  588|       |		
  589|   152M|		const nat local_range_end = atomic_load_explicit(global_range_end + thread_index, memory_order_relaxed);
  590|   152M|		p = 1;
  591|  2.14G|		for (nat i = 0; i < hole_count; i++) {
  592|  1.98G|			end[positions[i]] = (byte) ((local_range_end / p) % (nat) (positions[i] & 3 ? operation_count : 5));
  593|  1.98G|			p *= (nat) (positions[i] & 3 ? operation_count : 5);
  594|  1.98G|		}
  595|       |
  596|       |
  597|   152M|		nat zindex = 0;
  598|   152M|		p = 1;
  599|  2.14G|		for (byte i = 0; i < hole_count; i++) {
  600|  1.98G|			zindex += p * graph[positions[i]];
  601|  1.98G|			p *= (nat) (positions[i] & 3 ? operation_count : 5);
  602|  1.98G|		}
  603|   152M|		atomic_store_explicit(global_range_begin + thread_index, zindex, memory_order_relaxed);
  604|       |
  605|       |		
  606|       |		//printf("worker_thread[%llu]: updating begin and end,   pulled range_end=%llu, published range_begin=%llu]\n", thread_index, local_range_end, zindex);
  607|       |
  608|   152M|		publish_counter = 0;
  609|       |
  610|   152M|	} else publish_counter++;
  611|       |
  612|   152M|	u16 was_utilized = 0;
  613|   152M|	byte at = 0;
  614|       |
  615|       |
  616|   152M|	for (byte index = 20; index < graph_count - 4; index += 4) {
  617|      0|		if (graph[index] > graph[index + 4]) { at = index + 4; goto bad; } // WRONG: was     at = index   which is incorrect. 
  618|      0|	}                                                                      //       don't edit this to get the original semantics.
  619|       |
  620|       |
  621|   934M|	for (byte index = operation_count; index--;) {
  622|       |
  623|   892M|		if (graph[4 * index + 3] == index) {  at = 4 * index + 3; goto bad; }
  624|   847M|		if (graph[4 * index] == one   and graph[4 * index + 2] == index) {  at = 4 * index; goto bad; }
  625|   847M|		if (graph[4 * index] == six   and graph[4 * index + 2])          {  at = 4 * index; goto bad; }
  626|   847M|		if (graph[4 * index] == two   and graph[4 * index + 2] == index) {  at = 4 * index + 2 * (index == two); goto bad; }
  627|   836M|		if (graph[4 * index] == three and graph[4 * index + 1] == index) {  at = 4 * index + 1 * (index == three); goto bad; }
  628|       |
  629|   836M|		if (graph[4 * index] == six and graph[4 * graph[4 * index + 3]] == one) {
  630|    415|			if (index == six) { at = 4 * index + 3; goto bad; } 
  631|      6|			const byte tohere = graph[4 * index + 3];
  632|      6|			if (tohere == one) { at = 4 * index; goto bad; }
  633|      0|			at = 4 * (index < tohere ? index : tohere); goto bad;
  634|      6|		}
  635|       | 
  636|   836M|		if (graph[4 * index] == six and graph[4 * graph[4 * index + 3]] == five) {
  637|    415|			if (index == six) { at = 4 * index + 3; goto bad; } 
  638|      6|			const byte tohere = graph[4 * index + 3];
  639|      6|			if (tohere == five) { at = 4 * index; goto bad; }
  640|      0|			at = 4 * (index < tohere ? index : tohere); goto bad; 
  641|      6|		}
  642|       | 
  643|   836M|		const byte l = graph[4 * index + 1], g = graph[4 * index + 2], e = graph[4 * index + 3];
  644|       |
  645|   836M|		if (graph[4 * index] == one and graph[4 * e] == one) {
  646|  8.68M|			if (index == one) { at = 4 * index + 3; goto bad; }
  647|  18.5k|			if (e == one) { at = 4 * index; goto bad; }
  648|  18.4k|			at = 4 * (index < e ? index : e); goto bad;
  649|  18.5k|		}
  650|       |
  651|   827M|		if (graph[4 * index] == five and l == g and l == e and graph[4 * e] == one) {
  652|  1.02k|			if (index == five) { at = 4 * index + 1; goto bad; } 
  653|      1|			if (e == one) { at = 4 * index; goto bad; }
  654|      0|			at = 4 * (index < e ? index : e); goto bad; 
  655|      1|		}
  656|       |
  657|   827M|		if (graph[4 * index] == five and l == g and l == e and graph[4 * e] == three) {
  658|  1.09k|			if (index == five) { at = 4 * index + 1; goto bad; } 
  659|      1|			if (e == three) { at = 4 * index; goto bad; }
  660|      0|			at = 4 * (index < e ? index : e); goto bad; 
  661|      1|		}
  662|       |
  663|   827M|		if (graph[4 * index] == one)
  664|   589M|			for (byte offset = 1; offset < 4; offset++) 
  665|   476M|				if (graph[4 * graph[4 * index + offset]] == five) { 
  666|  45.8M|					if (index == one) { at = 4 * index + offset; goto bad; } 
  667|  18.4E|					const byte tohere = graph[4 * index + offset];
  668|  18.4E|					if (tohere == five) { at = 4 * index; goto bad; }
  669|  18.4E|					at = 4 * (index < tohere ? index : tohere); goto bad; 
  670|  18.4E|				}
  671|       |		
  672|   781M|		if (graph[4 * index] == five) 
  673|   705M|			for (byte offset = 1; offset < 4; offset++) 
  674|   529M|				if (graph[4 * graph[4 * index + offset]] == five) { 
  675|  28.5k|					if (index == five) { at = 4 * index + offset; goto bad; } 
  676|    127|					const byte tohere = graph[4 * index + offset];
  677|    127|					if (tohere == five) { at = 4 * index; goto bad; } 
  678|     52|					at = 4 * (index < tohere ? index : tohere); goto bad; 
  679|    127|				}
  680|       |
  681|   781M|		if (graph[4 * index] == six) 
  682|   628M|			for (byte offset = 1; offset < 4; offset++) 
  683|   471M|				if (graph[4 * graph[4 * index + offset]] == six) { 
  684|     18|					if (index == six) { at = 4 * index + offset; goto bad; } 
  685|     10|					const byte tohere = graph[4 * index + offset];
  686|     10|					if (tohere == six) { at = 4 * index; goto bad; } 
  687|      3|					at = 4 * (index < tohere ? index : tohere); goto bad; 
  688|     10|				}
  689|       |
  690|   781M|		if (graph[4 * index] == three) 
  691|   668M|			for (byte offset = 1; offset < 4; offset++) 
  692|   501M|				if (graph[4 * graph[4 * index + offset]] == three) { 
  693|   117k|					if (index == three) { at = 4 * index + offset; goto bad; } 
  694|     90|					const byte tohere = graph[4 * index + offset];
  695|     90|					if (tohere == three) { at = 4 * index; goto bad; } 
  696|     19|					at = 4 * (index < tohere ? index : tohere); goto bad; 
  697|     90|				}
  698|       |		
  699|   818M|		if (l != index) was_utilized |= 1 << l;
  700|   839M|		if (g != index) was_utilized |= 1 << g;
  701|   835M|		if (e != index) was_utilized |= 1 << e;
  702|   781M|	}
  703|       |
  704|   558M|	for (byte index = 0; index < operation_count; index++) 
  705|   574M|		if (not ((was_utilized >> index) & 1)) goto loop;
  706|  18.4E|	goto try_executing;
  707|  18.4E|bad:
  708|  97.4M|	for (byte i = 0; i < hole_count; i++) {
  709|  97.4M|		if (positions[i] == at) { pointer = i; goto loop; } else graph[positions[i]] = 0;
  710|  97.4M|	}
  711|  18.4E|	abort();
  712|       |	
  713|  80.0M|try_executing:;
  714|  82.0M|	nat pm = fea_execute_graph(graph, array);       if (pm) { pms[pm]++; goto loop; } 
  715|  18.4E|	byte origin;
  716|  18.4E|	    pm = execute_graph(graph, array, &origin);  if (pm) { pms[pm]++; goto loop; } 
  717|       |
  718|  18.4E|	pms[z_is_good]++; 
  719|  18.4E|	append_to_file(filename, sizeof filename, graph, origin);
  720|       |
  721|  18.4E|	printf("\n    FOUND:  z = "); 
  722|  18.4E|	print_graph_raw(graph); 
  723|  18.4E|	printf("\n"); 
  724|  18.4E|	fflush(stdout);
  725|  18.4E|        goto loop;
  726|       |
  727|  53.0M|reset_:
  728|  53.0M|	graph[positions[pointer]] = 0; 
  729|  53.0M|	pointer++;
  730|  53.0M|	goto loop;
  731|       |
  732|      6|terminate_thread:
  733|       |
  734|      6|	pthread_mutex_lock(&mutex);
  735|      6|	atomic_store_explicit(global_range_begin + thread_index, 0, memory_order_relaxed);
  736|      6|	atomic_store_explicit(global_range_end   + thread_index, 0, memory_order_relaxed);
  737|      6|	pthread_mutex_unlock(&mutex);
  738|       |
  739|      6|	printf("worker_thread[%llu]: terminating thread!  (thread with filename=\"%s\")\n", thread_index, filename);
  740|      6|	free(raw_graph);
  741|      6|	free(raw_end);
  742|      6|	free(array);
  743|      6|	return pms;
  744|  18.4E|}
  745|       |
  746|      3|static nat expn(nat base, nat exponent) {
  747|      3|	nat result = 1;
  748|     16|	for (nat i = 0; i < exponent; i++) result *= base;
  749|      3|	return result;
  750|      3|}
  751|       |
  752|  11.1k|static void print(char* filename, size_t size, const char* string) {
  753|  11.1k|	char dt[32] = {0};   get_datetime(dt);
  754|       |
  755|  11.1k|	int flags = O_WRONLY | O_APPEND;
  756|  11.1k|	mode_t permissions = 0;
  757|  11.1k|try_open:;
  758|  11.1k|	const int file = open(filename, flags, permissions);
  759|  11.1k|	if (file < 0) {
  760|      1|		if (permissions) {
  761|      0|			perror("create openat file");
  762|      0|			printf("print: [%s]: failed to create filename = \"%s\"\n", dt, filename);
  763|      0|			fflush(stdout);
  764|      0|			abort();
  765|      0|		}
  766|      1|		snprintf(filename, size, "%s_D%hhuR%hhu_%08x%08x%08x%08x_output.txt", dt, D, R,
  767|      1|			rand(), rand(), rand(), rand()
  768|      1|		);
  769|      1|		flags = O_CREAT | O_WRONLY | O_APPEND | O_EXCL;
  770|      1|		permissions = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
  771|      1|		goto try_open;
  772|      1|	}
  773|       |
  774|  11.1k|	write(file, string, strlen(string));
  775|  11.1k|	close(file);
  776|  11.1k|	printf("%s", string);
  777|  11.1k|	fflush(stdout);
  778|  11.1k|}
  779|       |
  780|      1|int main(void) {
  781|      1|	static char output_filename[4096] = {0};
  782|      1|	static char output_string[4096] = {0};
  783|       |	
  784|      1|	srand((unsigned)time(0)); rand();
  785|      1|	space_size = expn(5 + D, 9) * expn(5 * expn(5 + D, 3), D);
  786|      1|	positions = calloc(hole_count, 1);
  787|      1|	threads = calloc(thread_count, sizeof(pthread_t));
  788|     10|	for (byte i = 0; i < initial; i++) positions[i] = R ? _63R_hole_positions[i] : _36R_hole_positions[i];
  789|      5|	for (byte i = 0; i < 4 * D; i++) positions[initial + i] = 20 + i; 
  790|       |
  791|      1|	snprintf(output_string, 4096, "SRNFGPR: searching [D=%hhu, R=%hhu] space....\n", D, R);
  792|      1|	print(output_filename, 4096, output_string);
  793|       |
  794|      1|	global_range_begin = calloc(thread_count,sizeof(_Atomic nat));
  795|      1|	global_range_end = calloc(thread_count,sizeof(_Atomic nat));
  796|       |
  797|      1|	pthread_mutex_init(&mutex, NULL);
  798|       |
  799|      1|	const nat width = space_size / thread_count;
  800|      1|	nat begin = 0;
  801|      7|	for (nat i = 0; i < thread_count; i++) {
  802|      6|		atomic_init(global_range_begin + i, begin);
  803|      6|		atomic_init(global_range_end + i, i < thread_count - 1 ? begin + width - 1 : space_size - 1);
  804|      6|		begin += width;
  805|      6|	}
  806|       |
  807|      1|	struct timeval time_begin = {0};
  808|      1|	gettimeofday(&time_begin, NULL);
  809|       |
  810|      7|	for (nat i = 0; i < thread_count; i++) {
  811|      6|		nat* thread_index = malloc(sizeof(nat));
  812|      6|		*thread_index = i;
  813|      6|		pthread_create(threads + i, NULL, worker_thread, thread_index);
  814|      6|	}
  815|       |
  816|      1|	nat* local_begin = calloc(thread_count, sizeof(nat));
  817|      1|	nat* local_end = calloc(thread_count, sizeof(nat));
  818|       |
  819|     60|	while (1) {
  820|       |
  821|    420|		for (nat i = 0; i < thread_count; i++) {
  822|    360|			local_begin[i] = atomic_load_explicit(global_range_begin + i, memory_order_relaxed);
  823|    360|			local_end[i] = atomic_load_explicit(global_range_end + i, memory_order_relaxed);
  824|    360|		}
  825|       |		
  826|     60|		nat largest_remaining = 0, chosen_thread = 0;
  827|       |
  828|    420|		for (nat i = 0; i < thread_count; i++) {
  829|    360|			if (local_begin[i] > local_end[i]) local_begin[i] = local_end[i];
  830|    360|			const nat size = local_end[i] - local_begin[i];
  831|    360|			if (size > largest_remaining) { largest_remaining = size; chosen_thread = i; }
  832|    360|		}
  833|       |
  834|     60|		snprintf(output_string, 4096, "\033[H\033[2J");
  835|     60|		print(output_filename, 4096, output_string);
  836|       |
  837|     60|		snprintf(output_string, 4096, "\n-----------------printing current job allocations (largest_remaining: %llu)-------------------\n", largest_remaining);
  838|     60|		print(output_filename, 4096, output_string);
  839|       |
  840|     60|		nat sum = 0;
  841|       |
  842|    420|		for (nat i = 0; i < thread_count; i++) {
  843|    360|			const nat size = local_end[i] - local_begin[i];
  844|    360|			sum += size;
  845|    360|		}
  846|       |
  847|     60|		snprintf(output_string, 4096, "\n\t%1.10lf%%\n\n", (double) (space_size - sum) / (double) space_size);
  848|     60|		print(output_filename, 4096, output_string);
  849|       |
  850|    420|		for (nat i = 0; i < thread_count; i++) { 
  851|       |
  852|    360|			snprintf(output_string, 4096, "  %c %020llu : %020llu :: ", i == chosen_thread ? '*' : ' ', local_begin[i], local_end[i]);
  853|    360|			print(output_filename, 4096, output_string);
  854|       |
  855|    360|			const nat diff = local_end[i] - local_begin[i];
  856|    360|			const nat zs_per_char = space_size / 360;
  857|    360|			const nat amount = diff / zs_per_char;
  858|       |
  859|  10.5k|			for (nat j = 0; j < amount; j++) {
  860|  10.1k|				snprintf(output_string, 4096, "#");
  861|  10.1k|				print(output_filename, 4096, output_string);
  862|  10.1k|			}
  863|    360|			snprintf(output_string, 4096, "\n");
  864|    360|			print(output_filename, 4096, output_string);
  865|       |			
  866|    360|		}
  867|     60|		snprintf(output_string, 4096, "\n");
  868|     60|		print(output_filename, 4096, output_string);
  869|       |
  870|     60|		if (not largest_remaining) break;
  871|     59|		sleep(1 << display_rate);
  872|     59|	}
  873|       |
  874|      1|	nat counts[pm_count] = {0};
  875|      7|	for (nat i = 0; i < thread_count; i++) {
  876|      6|		nat* local_counts = NULL;
  877|      6|		pthread_join(threads[i], (void**) &local_counts);
  878|    216|		for (nat j = 0; j < pm_count; j++) counts[j] += local_counts[j];
  879|      6|		free(local_counts);
  880|      6|	}
  881|       |
  882|      1|	nat sum = 0;
  883|     36|	for (nat i = 0; i < pm_count; i++) sum += counts[i];
  884|      1|	counts[pm_ga] = space_size - sum;
  885|       |
  886|      1|	struct timeval time_end = {0};
  887|      1|	gettimeofday(&time_end, NULL);
  888|       |
  889|      1|	const double seconds = difftime(time_end.tv_sec, time_begin.tv_sec), zthroughput = (double) space_size / seconds;
  890|      1|	char time_begin_dt[32] = {0}, time_end_dt[32] = {0};
  891|      1|	strftime(time_end_dt,   32, "1%Y%m%d%u.%H%M%S", localtime(&time_end.tv_sec));
  892|      1|	strftime(time_begin_dt, 32, "1%Y%m%d%u.%H%M%S", localtime(&time_begin.tv_sec));
  893|       |
  894|      1|	snprintf(output_string, 4096, "using [D=%hhu, R=%hhu]:"
  895|      1|			"\n\tspace_size=%llu"
  896|      1|			"\n\tthread_count=%llu"
  897|      1|			"\n\tminimum_split_size=%llu"
  898|      1|			"\n\trange_update_frequency=%llu"
  899|      1|			"\n\tdisplay_rate=%llu"
  900|      1|			"\n\tfea_execution_limit=%llu"
  901|      1|			"\n\texecution_limit=%llu"
  902|      1|			"\n\tarray_size=%llu"
  903|      1|			"\n\n"
  904|      1|			"\n\t""searched %llu zvs"
  905|      1|			"\n\tusing %llu threads"
  906|      1|			"\n\tin %10.2lfs [%s:%s],"
  907|      1|			"\n\tat %10.2lf z/s."
  908|      1|			"\n\n\npm counts:\n", 
  909|       |
  910|      1|			D, R,   space_size,  thread_count,  
  911|      1|			minimum_split_size,  range_update_frequency, display_rate,
  912|      1|			fea_execution_limit,  execution_limit,  array_size,  space_size, 
  913|      1|			thread_count,  seconds,  time_begin_dt,  time_end_dt,  zthroughput
  914|      1|	);
  915|       |
  916|      1|	print(output_filename, 4096, output_string);
  917|     36|	for (nat i = 0; i < pm_count; i++) {
  918|     35|		if (i and not (i % 2)) {
  919|     17|			snprintf(output_string, 4096, "\n");
  920|     17|			print(output_filename, 4096, output_string);
  921|     17|		}
  922|     35|		snprintf(output_string, 4096, "%6s: %-8lld\t\t", pm_spelling[i], counts[i]);
  923|     35|		print(output_filename, 4096, output_string);
  924|     35|	}
  925|      1|	snprintf(output_string, 4096, "\n[done]\n");
  926|      1|	print(output_filename, 4096, output_string);
  927|      1|}
  928|       | 
  929|       |
  930|       |
  931|       |
  932|       |
  933|       |
  934|       |
  935|       |
  936|       |
  937|       |
  938|       |
  939|       |
  940|       |
  941|       |
  942|       |
  943|       |
  944|       |
  945|       |
  946|       |
  947|       |
  948|       |
  949|       |
  950|       |
  951|       |
  952|       |
  953|       |
  954|       |
  955|       |
  956|       |
  957|       |
  958|       |
  959|       |
  960|       |
  961|       |
  962|       |/*
  963|       |202405293.180937:
  964|       |
  965|       |implementing the binary space partition (BSP) opt:   a solution to 
  966|       |	parellelizing while maining sequential executeion 
  967|       |		as much as posisble for z skips. 
  968|       |
  969|       |
  970|       |	the implementation goes as follows:
  971|       |
  972|       |
  973|       |			first partition the space into 64 parts, each one given to a worker thread, 
  974|       |
  975|       |				run each one using the sr,      supplying it a range_begin and range_end   
  976|       |
  977|       |					both of which are global and atomic, 
  978|       |
  979|       |						on initial execution:
  980|       |
  981|       |						the thread reads the range begin, inits graph to it via a reduce()
  982|       |
  983|       |
  984|       |						the thread reads range_end and inits end[] to it, via a reduce()
  985|       |
  986|       |					the graph then does the standard loop containing ga, fea execute, and execute, 
  987|       |
  988|       |
  989|       |					every 100th (or so) iteration,   we will "publish the current graph state, 
  990|       |
  991|       |						via this code:
  992|       |
  993|       |
  994|       |
  995|       |
  996|       |
  997|       |					nat zindex = 0;
  998|       |					p = 1;
  999|       |					for (byte i = 0; i < hole_count; i++) {
 1000|       |						zindex += p * graph[positions[i]];
 1001|       |						p *= (nat) (positions[i] & 3 ? operation_count : 5);
 1002|       |					}
 1003|       |					atomic_store_explicit(&range_begin[this_thread], zindex, memory_order_relaxed);
 1004|       |				
 1005|       |
 1006|       |
 1007|       |				
 1008|       |
 1009|       |
 1010|       |
 1011|       |				ie, we are doing a unreduce on the graph, to get a zindex  and then we are storing that zi into our thread's global atomic range_begin state.   ie, we loose the original value of range_begin, set by main.  we don't need it anymore. 
 1012|       |
 1013|       |				
 1014|       |
 1015|       |
 1016|       |				additionally, after updating  or "publishing"   our progress, via range_begin, 
 1017|       |
 1018|       |
 1019|       |				we update our local copy of    end[]  to reflect the current state of range_end   which might have been edited by other worker threads, from them taking half of our job's z values. 
 1020|       |
 1021|       |
 1022|       |
 1023|       |				to do this, we just use this code:
 1024|       |
 1025|       |
 1026|       |
 1027|       |
 1028|       |
 1029|       |
 1030|       |
 1031|       |
 1032|       |				const nat range_end = atomic_load_explicit(global__range_end, memory_order_relaxed);
 1033|       |				p = 1;
 1034|       |				for (nat i = 0; i < hole_count; i++) {
 1035|       |					end[positions[i]] = (byte) ((range_end / p) % (nat) (positions[i] & 3 ? operation_count : 5));
 1036|       |					p *= (nat) (positions[i] & 3 ? operation_count : 5);
 1037|       |				}
 1038|       |				
 1039|       |
 1040|       |
 1041|       |
 1042|       |
 1043|       |
 1044|       |
 1045|       |
 1046|       |
 1047|       |				so end    and thus end_64      are now reflecting the true values   
 1048|       |
 1049|       |
 1050|       |					ie     in this case,   the global atomic values     global__range_end, are the master copy, 
 1051|       |
 1052|       |
 1053|       |					but in the case of range_begin,    the local_copies are master copies,   
 1054|       |
 1055|       |
 1056|       |						and synch'ing up again involves ovewrwritting the non-master copy with the master copy, of course
 1057|       |
 1058|       |
 1059|       |					
 1060|       |				
 1061|       |
 1062|       |
 1063|       |
 1064|       |		so once all of this in place, 
 1065|       |
 1066|       |			now the binary space partitoning part   comes in-
 1067|       |
 1068|       |				when a thread finishes, it simply checks the global_range_begin  and global_range_end   arrays, 
 1069|       |
 1070|       |
 1071|       |			and searches it and finds the i such that    global_range_end[i] - global_range_begin[i]   is the largest
 1072|       |
 1073|       |
 1074|       |
 1075|       |				and then it takes     that difference    divides it in half,   and then subtracts that much from global_range_end[i]
 1076|       |
 1077|       |
 1078|       |
 1079|       |						this is the thread taking half of the work from the thread that has the least amount done!
 1080|       |
 1081|       |
 1082|       |
 1083|       |				thus binary partitioning the search space!    pretty cool 
 1084|       |
 1085|       |
 1086|       |
 1087|       |
 1088|       |
 1089|       |		then, the thread continues with this job-  given by simply:    
 1090|       |
 1091|       |		local_range_begin = global_range_end[i]     (but after the subtraction was performed)
 1092|       |		
 1093|       |		local_range_end = global_range_end[i]       (but BEFORE  the subtraction was performed)
 1094|       |
 1095|       |
 1096|       |
 1097|       |		then the process starts over, using those local range begin and end. 
 1098|       |
 1099|       |
 1100|       |
 1101|       |
 1102|       |
 1103|       |
 1104|       |
 1105|       |
 1106|       |
 1107|       |
 1108|       |
 1109|       |
 1110|       |
 1111|       |
 1112|       |
 1113|       |
 1114|       |
 1115|       |
 1116|       |
 1117|       |
 1118|       |
 1119|       |publish_begin() {
 1120|       |
 1121|       |	nat zindex = 0;
 1122|       |	p = 1;
 1123|       |	for (byte i = 0; i < hole_count; i++) {
 1124|       |		zindex += p * graph[positions[i]];
 1125|       |		p *= (nat) (positions[i] & 3 ? operation_count : 5);
 1126|       |	}
 1127|       |	atomic_store_explicit(&global_range_begin[thread_index], zindex, memory_order_relaxed);
 1128|       |}
 1129|       |
 1130|       |
 1131|       |
 1132|       |pull_end() {
 1133|       |
 1134|       |	const nat range_end = atomic_load_explicit(global_range_end[thread_index], memory_order_relaxed);
 1135|       |	p = 1;
 1136|       |	for (nat i = 0; i < hole_count; i++) {
 1137|       |		end[positions[i]] = (byte) ((range_end / p) % (nat) (positions[i] & 3 ? operation_count : 5));
 1138|       |		p *= (nat) (positions[i] & 3 ? operation_count : 5);
 1139|       |	}
 1140|       |				
 1141|       |}
 1142|       |
 1143|       |
 1144|       |
 1145|       |
 1146|       |
 1147|       |main
 1148|       |
 1149|       |
 1150|       |	pthread_mutex_init(&mutex, 0);
 1151|       |
 1152|       |
 1153|       |
 1154|       |
 1155|       |
 1156|       |	
 1157|       |worker_thread() {
 1158|       |
 1159|       |start_first_job:
 1160|       |
 1161|       |	// load range_begin and range_end   
 1162|       |	// from global arrays  at thread index (TI)
 1163|       |
 1164|       |	nat range_begin = atomic_load(global_range_begin[thread_index], mor);
 1165|       |	nat range_end = atomic_load(global_range_end[thread_index], mor);
 1166|       |
 1167|       |
 1168|       |next_job:
 1169|       |	...reduce range_begin and range_end   to be graph   and graph_end  (end)...
 1170|       |	// now we are ready to start the job
 1171|       |
 1172|       |	loop:
 1173|       |
 1174|       |		
 1175|       |		check if job is done, (ie graph is at end) if so goto done
 1176|       |
 1177|       |	init:
 1178|       |		if (publish_counter >= 500) {
 1179|       |
 1180|       |			publish_begin();
 1181|       |			pull_end();
 1182|       |
 1183|       |			publish_counter = 0;
 1184|       |		} else publish_counter++;
 1185|       |		...do job...
 1186|       |
 1187|       |		goto loop;
 1188|       |
 1189|       |	done:
 1190|       |
 1191|       |		pthread_mutex_lock(&mutex);
 1192|       |
 1193|       |		nat max_diff = 0;
 1194|       |		nat max_ti = 0;
 1195|       |		for (each thread index   ti < 64) {
 1196|       |			const nat b = atomic_load(global_range_begin[ti], mor);
 1197|       |			const nat e = atomic_load(global_range_end[ti], mor);
 1198|       |			const nat diff =  e - b;
 1199|       |			if (diff > max_diff) { max_diff = diff; max_ti = ti; }
 1200|       |		}
 1201|       |
 1202|       |		if (max_diff < minimum_split_size) goto terminate;
 1203|       |		
 1204|       |		const nat amount = (max_diff >> 1);
 1205|       |		const nat e = atomic_fetch_sub(global_range_end[max_ti], amount + 1, mor);
 1206|       |		pthread_mutex_unlock(&mutex);
 1207|       |		range_begin = e - amount;
 1208|       |		range_end = e;
 1209|       |		goto next_job;
 1210|       |terminate:
 1211|       |	...
 1212|       |	pthread_exit(0);
 1213|       |	free(...);
 1214|       |}
 1215|       |
 1216|       |
 1217|       |
 1218|       |
 1219|       |
 1220|       |
 1221|       |
 1222|       |
 1223|       |
 1224|       |
 1225|       |[ 0 ... N )     [ N ... W )                W = 10
 1226|       |
 1227|       |
 1228|       |bob's range_begin = 0
 1229|       |bob's range_end = 9
 1230|       |
 1231|       |
 1232|       |          2 3 4 5     6     9
 1233|       |      D D X X X X     X X X X 
 1234|       |          ^
 1235|       |
 1236|       |
 1237|       |
 1238|       |
 1239|       |
 1240|       |
 1241|       |
 1242|       |bob:
 1243|       |       XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX P XXXXXXXXXXX......M..............
 1244|       |							     |
 1245|       |      zi=0                             zi=1000              -|-          zi=5000
 1246|       |						             |
 1247|       |						             |
 1248|       |					         joe:         XXXXXXXXXXXXXX
 1249|       |
 1250|       |
 1251|       |
 1252|       |
 1253|       |
 1254|       |
 1255|       |
 1256|       |
 1257|       |
 1258|       |*/
 1259|       |
 1260|       |
 1261|       |
 1262|       |
 1263|       |
 1264|       |
 1265|       |
 1266|       |
 1267|       |
 1268|       |
 1269|       |
 1270|       |
 1271|       |
 1272|       |
 1273|       |
 1274|       |
 1275|       |
 1276|       |
 1277|       |
 1278|       |
 1279|       |
 1280|       |
 1281|       |
 1282|       |
 1283|       |
 1284|       |
 1285|       |
 1286|       |
 1287|       |
 1288|       |
 1289|       |
 1290|       |
 1291|       |
 1292|       |
 1293|       |
 1294|       |
 1295|       |
 1296|       |
 1297|       |
 1298|       |
 1299|       |
 1300|       |
 1301|       |
 1302|       |
 1303|       |
 1304|       |
 1305|       |
 1306|       |
 1307|       |
 1308|       |
 1309|       |
 1310|       |
 1311|       |
 1312|       |
 1313|       |
 1314|       |
 1315|       |
 1316|       |
 1317|       |
 1318|       |
 1319|       |
 1320|       |
 1321|       |
 1322|       |
 1323|       |
 1324|       |
 1325|       |
 1326|       |
 1327|       |
 1328|       |
 1329|       |
 1330|       |
 1331|       |
 1332|       |
 1333|       |
 1334|       |
 1335|       |
 1336|       |
 1337|       |
 1338|       |
 1339|       |
 1340|       |
 1341|       |
 1342|       |
 1343|       |
 1344|       |
 1345|       |
 1346|       |
 1347|       |
 1348|       |
 1349|       |
 1350|       |
 1351|       |
 1352|       |/*
 1353|       |
 1354|       |
 1355|       |	// TODO:  use "memory_order_relaxed" !?!?!?!?!?!?!??!?????
 1356|       |				// CHANGED:   yup, its correct i think.
 1357|       |
 1358|       |
 1359|       |
 1360|       |
 1361|       |
 1362|       |
 1363|       |
 1364|       |
 1365|       |
 1366|       |
 1367|       |
 1368|       |static nat execute_graph_starting_at(byte origin) {
 1369|       |
 1370|       |
 1371|       |}
 1372|       |
 1373|       |
 1374|       |
 1375|       |
 1376|       |
 1377|       |
 1378|       |
 1379|       |
 1380|       |
 1381|       |
 1382|       |static nat execute_graph(void) {
 1383|       |	
 1384|       |}
 1385|       |
 1386|       |static nat fea_execute_graph_starting_at(byte origin) {
 1387|       |
 1388|       |	
 1389|       |}
 1390|       |
 1391|       |static nat fea_execute_graph(void) {
 1392|       |
 1393|       |}
 1394|       |
 1395|       |
 1396|       |
 1397|       |
 1398|       |
 1399|       |
 1400|       |
 1401|       |
 1402|       |
 1403|       |
 1404|       |
 1405|       |
 1406|       |*/
 1407|       |
 1408|       |
 1409|       |
 1410|       |
 1411|       |
 1412|       |
 1413|       |
 1414|       |
 1415|       |
 1416|       |
 1417|       |
 1418|       |
 1419|       |
 1420|       |
 1421|       |
 1422|       |
 1423|       |
 1424|       |
 1425|       |
 1426|       |
 1427|       |
 1428|       |
 1429|       |
 1430|       |
 1431|       |
 1432|       |			// update progress bar here!!!   // ie, atomic load of "head".
 1433|       |			// (would detect if head is >= spacesize, and then start the joining process, if it is.
 1434|       |
 1435|       |
 1436|       |
 1437|       |
 1438|       |
 1439|       |
 1440|       |
 1441|       |
 1442|       |
 1443|       |
 1444|       |
 1445|       |
 1446|       |
 1447|       |
 1448|       |
 1449|       |
 1450|       |/*
 1451|       |
 1452|       |
 1453|       |
 1454|       |
 1455|       |static void write_graph(nat b, nat e) {
 1456|       |
 1457|       |	get_datetime(buffer[buffer_count].dt);
 1458|       |	get_graphs_z_value(buffer[buffer_count].z);
 1459|       |	buffer_count++;
 1460|       |
 1461|       |	if (buffer_count == max_buffer_count) {
 1462|       |		append_to_file(b, e);
 1463|       |		buffer_count = 0;
 1464|       |	}
 1465|       |}
 1466|       |
 1467|       |
 1468|       |
 1469|       |
 1470|       |
 1471|       |
 1472|       |
 1473|       |
 1474|       |
 1475|       |
 1476|       |	//for (byte i = 0; i < graph_count; i += 4) {
 1477|       |	//
 1478|       |	//	if (	executed[i + 1] < 5 and graph[i + 1] or         // slightly concerning here... think about this more...? 
 1479|       |	//		executed[i + 2] < 5 and graph[i + 2] or 
 1480|       |	//		executed[i + 3] < 5 and graph[i + 3]) { a = pm_eda; goto bad; }
 1481|       |	//}
 1482|       |
 1483|       |
 1484|       |
 1485|       |///////////////
 1486|       |//	if (not (display_counter & ((1 << display_rate) - 1))) { print_graph_raw(); putchar(10); fflush(stdout); }
 1487|       |//	display_counter++;
 1488|       |//	nat zindex = 0;
 1489|       |//	nat p = 1;
 1490|       |//	for (byte i = 0; i < hole_count; i++) {
 1491|       |//		zindex += p * graph[positions[i]];
 1492|       |//		p *= (nat) (positions[i] & 3 ? operation_count : 5);
 1493|       |//	}
 1494|       |////////////////
 1495|       |
 1496|       |
 1497|       |
 1498|       |
 1499|       |
 1500|       |
 1501|       |
 1502|       |
 1503|       |
 1504|       |
 1505|       |x	array = calloc(array_size + 1, sizeof(nat));
 1506|       |x	timeout = calloc(operation_count, sizeof(nat));
 1507|       |
 1508|       |x	positions = calloc(hole_count, 1); 
 1509|       |	void* raw_graph = calloc(1, graph_count + (8 - (graph_count % 8)) % 8);
 1510|       |	void* raw_end = calloc(1, graph_count   + (8 - (graph_count % 8)) % 8);
 1511|       |
 1512|       |	graph = raw_graph;
 1513|       |	end = raw_end;
 1514|       |	uint64_t* graph_64 = raw_graph;
 1515|       |	uint64_t* end_64 = raw_end;
 1516|       |	nat display_counter = 0, found = 0;
 1517|       |	byte pointer = 0;
 1518|       |
 1519|       |	memcpy(graph, R ? _63R : _36R, 20);
 1520|       |	memcpy(end, R ? _63R : _36R, 20);
 1521|       |
 1522|       |
 1523|       |	nat p = 1;
 1524|       |	for (nat i = 0; i < hole_count; i++) {
 1525|       |		graph[positions[i]] = (byte) ((range_begin / p) % (nat) (positions[i] & 3 ? operation_count : 5));
 1526|       |		p *= (nat) (positions[i] & 3 ? operation_count : 5);
 1527|       |	}
 1528|       |	if (range_begin >= p) { puts("range_begin is too big!"); printf("range_begin = %llu, p = %llu\n", range_begin, p); abort(); }
 1529|       |
 1530|       |	p = 1;
 1531|       |	for (nat i = 0; i < hole_count; i++) {
 1532|       |		end[positions[i]] = (byte) ((range_end / p) % (nat) (positions[i] & 3 ? operation_count : 5));
 1533|       |		p *= (nat) (positions[i] & 3 ? operation_count : 5);
 1534|       |	}
 1535|       |	if (range_end >= p) { puts("range_end is too big!"); printf("range_end = %llu, p = %llu\n", range_end, p); abort(); }
 1536|       |
 1537|       |	
 1538|       |	goto init;
 1539|       |
 1540|       |
 1541|       |
 1542|       |
 1543|       |
 1544|       |
 1545|       |
 1546|       |
 1547|       |
 1548|       |
 1549|       |	if (argc != 2) { printf("./pth-srnfgpr [D=%hhu][R=%hhu] <threadcount:nat>\n", D, R); exit(0); }
 1550|       |
 1551|       |	char* threadcount_invalid = NULL;
 1552|       |	const nat threadcount = strtoull(argv[1], &threadcount_invalid, 10);
 1553|       |	if (*threadcount_invalid) {
 1554|       |		printf("ERROR: error parsing threadcount near \"%s\" aborting...\n", threadcount_invalid);
 1555|       |		abort();
 1556|       |	}
 1557|       |
 1558|       |
 1559|       |
 1560|       |
 1561|       |// printf("sleeping for %5.2lfs until:\n\n\talarm: %s\n\tnow:   %s\n\n", difference, alarm_spelling, now_spelling);
 1562|       |
 1563|       |
 1564|       |
 1565|       |
 1566|       |
 1567|       |static volatile int quit = 0;
 1568|       |static noreturn void handler(int __attribute__((unused))_) {
 1569|       |	puts("\ncanceled alarm.");
 1570|       |	quit = 1;
 1571|       |	abort();
 1572|       |}
 1573|       |
 1574|       |
 1575|       |
 1576|       |int main(int argc, const char** argv) {
 1577|       |	if (argc < 2) return puts("usage: ./alarm <string> <datetime:1%Y%m%d%u.%H%M%S>");
 1578|       |
 1579|       |	struct sigaction action = {.sa_handler = handler}; 
 1580|       |	sigaction(SIGINT, &action, NULL);
 1581|       |
 1582|       |	const char* purpose = argv[1];
 1583|       |	const char* alarm_string = argv[2];
 1584|       |	char now_spelling[32] = {0};
 1585|       |	char alarm_spelling[32] = {0};
 1586|       |
 1587|       |	struct tm alarm_details = {0};
 1588|       |	strptime(alarm_string, "1%Y%m%d%u.%H%M%S", &alarm_details);
 1589|       |	struct timeval the_alarm = { .tv_sec = timelocal(&alarm_details), .tv_usec = 0 };
 1590|       |	
 1591|       |	struct timeval now;
 1592|       |	gettimeofday(&now, NULL);
 1593|       |	const double difference = difftime(the_alarm.tv_sec, now.tv_sec);
 1594|       |
 1595|       |	strftime(alarm_spelling, 32, "1%Y%m%d%u.%H%M%S", localtime(&the_alarm.tv_sec));
 1596|       |	strftime(  now_spelling, 32, "1%Y%m%d%u.%H%M%S", localtime(&now.tv_sec));
 1597|       |	printf("sleeping for %5.2lfs until:\n\n\talarm: %s\n\tnow:   %s\n\n", difference, alarm_spelling, now_spelling);
 1598|       |
 1599|       |	puts("\tasleep...");
 1600|       |	sleep((unsigned) difference);
 1601|       |
 1602|       |	gettimeofday(&now, NULL);
 1603|       |	strftime(now_spelling, 32, "1%Y%m%d%u.%H%M%S", localtime(&now.tv_sec));
 1604|       |	printf("\n\n\t\t[ \033[1;31mALARM\033[0m ] : \033[1m %s \033[0m : \033[1m %s \033[0m\n\n", purpose, now_spelling);
 1605|       |	while (not quit) { system("afplay bell.wav"); sleep(1); }
 1606|       |
 1607|       |}
 1608|       |
 1609|       |
 1610|       |
 1611|       |
 1612|       |
 1613|       |
 1614|       |
 1615|       |
 1616|       |
 1617|       |
 1618|       |
 1619|       |
 1620|       |
 1621|       |typedef long long nat;
 1622|       |
 1623|       |static nat thread_count = 9;
 1624|       |static const nat job_count = 1000000;
 1625|       |
 1626|       |struct thread_arguments {
 1627|       |	nat index;
 1628|       |};
 1629|       |
 1630|       |static pthread_mutex_t input_mutex;
 1631|       |static pthread_mutex_t output_mutex;
 1632|       |
 1633|       |static _Atomic nat output_count = 0;
 1634|       |static _Atomic nat input_count = 0;
 1635|       |
 1636|       |static nat* output = NULL; 
 1637|       |static nat* input = NULL;
 1638|       |
 1639|       |
 1640|       |int main(int argc, const char** argv) {
 1641|       |	if (argc == 1) return puts("give the thread count as an argument!");
 1642|       |
 1643|       |	thread_count = atoi(argv[1]);
 1644|       |
 1645|       |	srand(42);
 1646|       |
 1647|       |	//clock_t begin = clock();
 1648|       |
 1649|       |	pthread_mutex_init(&output_mutex, NULL);
 1650|       |	pthread_mutex_init(&input_mutex, NULL);
 1651|       |
 1652|       |	input = calloc(job_count, sizeof(nat));
 1653|       |	output = calloc(job_count, sizeof(nat));
 1654|       |	
 1655|       |	for (nat i = 0; i < job_count; i++) 
 1656|       |		input[input_count++] = (nat) (rand() % 400);
 1657|       |	
 1658|       |	pthread_t* thread = calloc((size_t) thread_count, sizeof(pthread_t));
 1659|       |
 1660|       |	for (nat i = 0; i < thread_count; i++) {
 1661|       |		struct thread_arguments* args = calloc(1, sizeof(struct thread_arguments));
 1662|       |		args->index = i;
 1663|       |		pthread_create(thread + i, NULL, worker_thread, args);
 1664|       |	}
 1665|       |
 1666|       |	for (nat i = 0; i < thread_count; i++) 
 1667|       |		pthread_join(thread[i], NULL);
 1668|       |
 1669|       |	printf("info: number of jobs completed = %llu\n", output_count);
 1670|       |
 1671|       |	pthread_mutex_destroy(&output_mutex);
 1672|       |	pthread_mutex_destroy(&input_mutex);
 1673|       |
 1674|       |	free(input);
 1675|       |	free(output);
 1676|       |
 1677|       |	//clock_t end = clock();
 1678|       |	//double total_time = (double)(end - begin) / CLOCKS_PER_SEC;
 1679|       |	//printf("\t time for %llu threads:   %10.10lfs\n", thread_count, total_time);
 1680|       |}
 1681|       |
 1682|       |
 1683|       |
 1684|       |
 1685|       |
 1686|       |
 1687|       |
 1688|       |
 1689|       |// atomic_fetch_add_explicit(&acnt, 1, memory_order_relaxed);
 1690|       |
 1691|       |
 1692|       |
 1693|       |
 1694|       |
 1695|       |
 1696|       |
 1697|       |
 1698|       |
 1699|       |
 1700|       |
 1701|       |
 1702|       |
 1703|       |
 1704|       |
 1705|       |
 1706|       |
 1707|       |
 1708|       |
 1709|       |
 1710|       |
 1711|       |
 1712|       |
 1713|       |
 1714|       |
 1715|       |
 1716|       |
 1717|       |
 1718|       |
 1719|       |
 1720|       |
 1721|       |
 1722|       |
 1723|       |
 1724|       |
 1725|       |
 1726|       |
 1727|       |
 1728|       |
 1729|       |
 1730|       |
 1731|       |
 1732|       |static void append_to_file(char* filename, size_t sizeof_filename, byte* graph) {
 1733|       |	char dt[32] = {0};   get_datetime(dt);
 1734|       |	char z[64] = {0};    get_graphs_z_value(z, graph);
 1735|       |	int flags = O_WRONLY | O_APPEND;
 1736|       |	mode_t permissions = 0;
 1737|       |
 1738|       |try_open:;
 1739|       |	const int file = open(filename, flags, permissions);
 1740|       |	if (file < 0) {
 1741|       |		if (permissions) {
 1742|       |			perror("create openat file");
 1743|       |			printf("filename=%s ", newfilename);
 1744|       |			close(dir); 	
 1745|       |			123456_ERROR:   DO SOMETHING TO FIX THIS!?!!?!
 1746|       |			abort();
 1747|       |		}
 1748|       |		char created_at[32] = {0};
 1749|       |		get_datetime(created_at);
 1750|       |		snprintf(filename, sizeof_filename, "%s_%08x%08x_z.txt", 
 1751|       |			created_at, arc4random(), arc4random()
 1752|       |		);
 1753|       |		flags = O_CREAT | O_WRONLY | O_APPEND | O_EXCL;
 1754|       |		permissions = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
 1755|       |		goto try_open;
 1756|       |	}
 1757|       |
 1758|       |	write(file, z, strlen(z));
 1759|       |	write(file, " ", 1);
 1760|       |	write(file, dt, strlen(dt));
 1761|       |	write(file, "\n", 1);
 1762|       |	close(file);
 1763|       |	printf("[%s]: write: %s z = %s to file \"%s\"\n", 
 1764|       |		dt, permission ? "created" : "wrote", z, filename
 1765|       |	);
 1766|       |}
 1767|       |
 1768|       |
 1769|       |
 1770|       |
 1771|       |
 1772|       |
 1773|       |
 1774|       |
 1775|       |
 1776|       |
 1777|       |
 1778|       |
 1779|       |
 1780|       |
 1781|       |static void write_file(const char* directory, char* name, size_t maxsize) {
 1782|       |	int flags = O_WRONLY | O_TRUNC;
 1783|       |	mode_t permission = 0;
 1784|       |	if (not *name) {
 1785|       |		srand((unsigned)time(0)); rand();
 1786|       |		char datetime[32] = {0};
 1787|       |		struct timeval t = {0};
 1788|       |		gettimeofday(&t, NULL);
 1789|       |		struct tm* tm = localtime(&t.tv_sec);
 1790|       |		strftime(datetime, 32, "1%Y%m%d%u.%H%M%S", tm);
 1791|       |		snprintf(name, maxsize, "%s%s_%08x%08x.txt", directory, datetime, rand(), rand());
 1792|       |		flags |= O_CREAT | O_EXCL;
 1793|       |		permission = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
 1794|       |	}
 1795|       |	int file = open(name, flags, permission);
 1796|       |	if (file < 0) { perror("save: open file"); puts(name); getchar(); }
 1797|       |	write(file, text, count);
 1798|       |	close(file);
 1799|       |}
 1800|       |
 1801|       |
 1802|       |
 1803|       |
 1804|       |
 1805|       |
 1806|       |
 1807|       |
 1808|       |
 1809|       |
 1810|       |char newfilename[4096] = {0};
 1811|       |	strncpy(newfilename, filename, sizeof newfilename);
 1812|       |	const int dir = open(directory, O_RDONLY | O_DIRECTORY, 0);
 1813|       |	if (dir < 0) { 
 1814|       |		perror("write open directory"); 
 1815|       |		printf("directory=%s ", directory); 
 1816|       |		return; 
 1817|       |	}
 1818|       |
 1819|       |
 1820|       |
 1821|       |
 1822|       |//     srand((unsigned)time(0)); rand();
 1823|       |
 1824|       |
 1825|       |
 1826|       |
 1827|       |
 1828|       |char datetime[32] = {0};
 1829|       |		struct timeval t = {0};
 1830|       |		gettimeofday(&t, NULL);
 1831|       |		struct tm* tm = localtime(&t.tv_sec);
 1832|       |		strftime(datetime, 32, "1%Y%m%d%u.%H%M%S", tm);
 1833|       |
 1834|       |
 1835|       |
 1836|       |
 1837|       |
 1838|       |perror("write openat file");
 1839|       |		printf("filename=%s\n", newfilename);
 1840|       |
 1841|       |
 1842|       |
 1843|       |
 1844|       |
 1845|       |
 1846|       |	char dt[32] = {0};
 1847|       |	get_datetime(dt);
 1848|       |	snprintf(newfilename, sizeof newfilename, "%s_%llu_%llu_z.txt", dt, b, e);
 1849|       |
 1850|       |	if (renameat(dir, filename, dir, newfilename) < 0) {
 1851|       |		perror("rename");
 1852|       |		printf("filename=%s newfilename=%s", filename, newfilename);
 1853|       |		close(dir); return;
 1854|       |	}
 1855|       |	printf("[\"%s\" renamed to  -->  \"%s\"]\n", filename, newfilename);
 1856|       |	strncpy(filename, newfilename, sizeof filename);
 1857|       |
 1858|       |	close(dir);
 1859|       |
 1860|       |
 1861|       |
 1862|       |
 1863|       |
 1864|       |
 1865|       |
 1866|       |
 1867|       |*/
 1868|       |
 1869|       |
 1870|       |
 1871|       |
 1872|       |
 1873|       |
 1874|       |
 1875|       |
 1876|       |
 1877|       |
 1878|       |
 1879|       |
 1880|       |
 1881|       |
 1882|       |
 1883|       |
 1884|       |
 1885|       |/*static void print_counts(void) {
 1886|       |	printf("printing pm counts:\n");
 1887|       |	for (nat i = 0; i < PM_count; i++) {
 1888|       |		if (i and not (i % 4)) puts("");
 1889|       |		printf("%6s: %8llu\t\t", pm_spelling[i], counts[i]);
 1890|       |	}
 1891|       |	puts("");
 1892|       |	puts("[done]");
 1893|       |}*/
 1894|       |
 1895|       |
 1896|       |
 1897|       |
 1898|       |
 1899|       |
 1900|       |
 1901|       |
 1902|       |
 1903|       |// if (not array[pointer])    { a = PM_ne0; goto bad; }     // delete me!!!!     redundant becuaes of pco.
 1904|       |
 1905|       |/*
 1906|       |
 1907|       |
 1908|       |
 1909|       |
 1910|       |
 1911|       |
 1912|       |
 1913|       |
 1914|       |
 1915|       |
 1916|       |for (byte o = 0; o < operation_count; o++) {
 1917|       |		if (graph[4 * o] != three) continue;
 1918|       |		if (not fea_execute_graph_starting_at(o, graph, array)) return false;
 1919|       |	}
 1920|       |	return true;
 1921|       |
 1922|       |
 1923|       |
 1924|       |
 1925|       |
 1926|       |
 1927|       |
 1928|       |
 1929|       |
 1930|       |
 1931|       |
 1932|       |
 1933|       |
 1934|       |
 1935|       |
 1936|       |
 1937|       |	const nat n = array_size;
 1938|       |	array[0] = 0; 
 1939|       |	array[n] = 0; 
 1940|       |	memset(timeout, 0, operation_count * sizeof(nat));
 1941|       |
 1942|       |	byte ip = origin, last_mcal_op = 0;
 1943|       |
 1944|       |	nat 	e = 0,  xw = 0,
 1945|       |		pointer = 0,  er_count = 0, 
 1946|       |	    	OER_er_at = 0,  OER_counter = 0, 
 1947|       |		R0I_counter = 0, H_counter = 0,
 1948|       |		RMV_counter = 0, RMV_value = 0, CSM_counter = 0;
 1949|       |
 1950|       |	for (; e < execution_limit; e++) {
 1951|       |
 1952|       |		if (e == expansion_check_timestep2) { 
 1953|       |			for (byte i = 0; i < 5; i++) {
 1954|       |				if (array[i] < required_s0_increments) return true; 
 1955|       |			}
 1956|       |		}
 1957|       |
 1958|       |		if (e == expansion_check_timestep)  { 
 1959|       |			if (er_count < required_er_count) return true; 
 1960|       |		}
 1961|       |		
 1962|       |		const byte I = ip * 4, op = graph[I];
 1963|       |
 1964|       |		for (nat i = 0; i < operation_count; i++) {
 1965|       |			if (timeout[i] >= execution_limit >> 1) return true; 
 1966|       |			timeout[i]++;
 1967|       |		}
 1968|       |		timeout[ip] = 0;
 1969|       |
 1970|       |		if (op == one) {
 1971|       |			if (pointer == n) return true; 
 1972|       |			if (not array[pointer]) return true; 
 1973|       |
 1974|       |			if (last_mcal_op == one) H_counter = 0;
 1975|       |			if (last_mcal_op == five) R0I_counter = 0;
 1976|       |
 1977|       |			pointer++;
 1978|       |
 1979|       |			if (pointer > xw and pointer < n) {    // <--------- ALSO CHANGED THIS ONE TOO.
 1980|       |				xw = pointer; 
 1981|       |				array[pointer] = 0; 
 1982|       |			}
 1983|       |		}
 1984|       |
 1985|       |		else if (op == five) {
 1986|       |			if (last_mcal_op != three) return true; 
 1987|       |			if (not pointer) return true; 
 1988|       |				
 1989|       |			if (	pointer == OER_er_at or 
 1990|       |				pointer == OER_er_at + 1) OER_counter++;
 1991|       |			else { OER_er_at = pointer; OER_counter = 0; }
 1992|       |			if (OER_counter >= max_acceptable_er_repetions) return true; 
 1993|       |			
 1994|       |			CSM_counter = 0;
 1995|       |			RMV_value = (nat) -1;
 1996|       |			RMV_counter = 0;
 1997|       |			for (nat i = 0; i < xw; i++) {
 1998|       |				if (array[i] < 6) CSM_counter++; else CSM_counter = 0;
 1999|       |				if (CSM_counter > max_acceptable_consequtive_small_modnats) return true; 
 2000|       |				if (array[i] == RMV_value) RMV_counter++; else { RMV_value = array[i]; RMV_counter = 0; }
 2001|       |				if (RMV_counter >= max_acceptable_modnat_repetions) return true; 
 2002|       |			}
 2003|       |
 2004|       |			pointer = 0;
 2005|       |			er_count++;
 2006|       |		}
 2007|       |
 2008|       |		else if (op == two) {
 2009|       |			array[n]++;
 2010|       |			if (array[n] >= 65535) return true; 
 2011|       |		}
 2012|       |
 2013|       |		else if (op == six) {  
 2014|       |			if (not array[n]) return true; 
 2015|       |			array[n] = 0;   
 2016|       |		}
 2017|       |
 2018|       |		else if (op == three) {
 2019|       |			if (last_mcal_op == three) return true; 
 2020|       |
 2021|       |			if (last_mcal_op == one) {
 2022|       |				H_counter++;
 2023|       |				if (H_counter >= max_acceptable_run_length) return true; 
 2024|       |			}
 2025|       |
 2026|       |			if (last_mcal_op == five) {
 2027|       |				R0I_counter++; 
 2028|       |				if (R0I_counter >= max_acceptable_consecutive_s0_incr) return true; 
 2029|       |			}
 2030|       |
 2031|       |			if (array[pointer] >= 65535) return true; 
 2032|       |			array[pointer]++;
 2033|       |		}
 2034|       |
 2035|       |		if (op == three or op == one or op == five) last_mcal_op = op;
 2036|       |
 2037|       |		byte state = 0;
 2038|       |		if (array[n] < array[pointer]) state = 1;
 2039|       |		if (array[n] > array[pointer]) state = 2;
 2040|       |		if (array[n] == array[pointer]) state = 3;
 2041|       |		ip = graph[I + state];
 2042|       |	}
 2043|       |	return false;
 2044|       |
 2045|       |
 2046|       |
 2047|       |
 2048|       |
 2049|       |
 2050|       |
 2051|       |
 2052|       |for (byte o = 0; o < operation_count; o++) {
 2053|       |		if (graph[4 * o] != three) continue;
 2054|       |		if (not execute_graph_starting_at(o, graph, array, timeout)) return false;
 2055|       |	}
 2056|       |	return true;
 2057|       |
 2058|       |
 2059|       |
 2060|       |
 2061|       |
 2062|       |
 2063|       |
 2064|       |
 2065|       |
 2066|       |
 2067|       |
 2068|       |
 2069|       |
 2070|       |
 2071|       |	const nat n = 5;
 2072|       |	array[n] = 0; 
 2073|       |	array[0] = 0; 
 2074|       |
 2075|       |	byte ip = origin, last_mcal_op = 0;
 2076|       |	nat pointer = 0, e = 0, xw = 0;
 2077|       |
 2078|       |	for (; e < fea_execution_limit; e++) {
 2079|       |
 2080|       |		const byte I = ip * 4, op = graph[I];
 2081|       |
 2082|       |		if (op == one) {
 2083|       |			if (pointer == n) return true;
 2084|       |			if (not array[pointer]) return true;
 2085|       |			pointer++;
 2086|       |
 2087|       |			// new correct lazy zeroing:
 2088|       |
 2089|       |			if (pointer > xw and pointer < n) { 
 2090|       |				xw = pointer; 
 2091|       |				array[pointer] = 0; 
 2092|       |			}
 2093|       |
 2094|       |
 2095|       |			// WAS:  if (pointer > xw) { xw = pointer; array[pointer] = 0; }   // ERROR HERE!!!!
 2096|       |			
 2097|       |			
 2098|       |
 2099|       |			/////////////////////////////////////////////////////////////////////////////////////////
 2100|       |			
 2101|       |
 2102|       |				//  WHAT IF pointer ALIAS's   STAR N!!!!!!!   CRAPPP
 2103|       |
 2104|       |				// we'll reset it, and thus change the graphs behavior!!!!
 2105|       |
 2106|       |
 2107|       |
 2108|       |
 2109|       |
 2110|       |					// we had added the lazy zeroing opt to the fea pass,  and thus the "i == n" alias condition will occur MUCH more likely!!!
 2111|       |
 2112|       |			/////////////////////////////////////////////////////////////////////////////////////////
 2113|       |
 2114|       |
 2115|       |
 2116|       |
 2117|       |		}
 2118|       |
 2119|       |		else if (op == five) {
 2120|       |			if (last_mcal_op != three) return true;
 2121|       |			if (not pointer) return true;
 2122|       |			pointer = 0;
 2123|       |		}
 2124|       |
 2125|       |		else if (op == two) { array[n]++; }
 2126|       |		else if (op == six) {  
 2127|       |			if (not array[n]) return true;
 2128|       |			array[n] = 0;   
 2129|       |		}
 2130|       |
 2131|       |		else if (op == three) {
 2132|       |			if (last_mcal_op == three) return true;
 2133|       |			array[pointer]++;
 2134|       |		}
 2135|       |
 2136|       |		if (op == three or op == one or op == five) last_mcal_op = op;
 2137|       |
 2138|       |		byte state = 0;
 2139|       |		if (array[n] < array[pointer]) state = 1;
 2140|       |		if (array[n] > array[pointer]) state = 2;
 2141|       |		if (array[n] == array[pointer]) state = 3;
 2142|       |		ip = graph[I + state];
 2143|       |	}
 2144|       |	return false; 
 2145|       |
 2146|       |
 2147|       |
 2148|       |
 2149|       |
 2150|       |
 2151|       |
 2152|       |
 2153|       |*/
 2154|       |
 2155|       |
 2156|       |
 2157|       |
 2158|       |//if (executed[I + state] < 253) executed[I + state]++;
 2159|       |
 2160|       |
 2161|       |
 2162|       |
 2163|       |
 2164|       |
 2165|       |
 2166|       |// TODO:  use "memory_order_relaxed" !?!?!?!?!?!?!??!?????
 2167|       |						// CHANGED: yup, we can just use memory_order_relaxed. 
 2168|       |
 2169|       |
 2170|       |
 2171|       |
 2172|       |
 2173|       |// only open part of the multithreading-zskip solution that we devised:    the sychronization part-
 2174|       |// we need this to COME BEFORE the atomic_fetch_add_explicit() call. 
 2175|       |// (using better  memory orderings  probably???...)
 2176|       |
 2177|       |
 2178|       |
 2179|       |
 2180|       |
 2181|       |
 2182|       |// {0 1 3 [4} ]
 2183|       |	// byte previous_op = graph[20];
 2184|       |	// make this not use this temporary variable, by using   index and index + 4   
 2185|       |	// (except if index+4==graphcount, then we will  just say its index.. yeah)
 2186|       |
 2187|       |	// constructive GA here
 2188|       |
 2189|       |
 2190|       |
 2191|       |
 2192|       |
 2193|       |     // here, we know we are doing a zskip, becuase we are over the end.
 2194|       |
 2195|       |
 2196|       |
 2197|       |
 2198|       |/*
 2199|       |if (range_begin >= p) { puts("range_begin is too big!"); printf("range_begin = %llu, p = %llu\n", range_begin, p); abort(); } // delete me?
 2200|       |	if (range_end >= p) { puts("range_end is too big!"); printf("range_end = %llu, p = %llu\n", range_end, p); abort(); }  // delete me?
 2201|       |*/
 2202|       |
 2203|       |
 2204|       |
 2205|       |
 2206|       |/*	nat zindex = 0;
 2207|       |	p = 1;
 2208|       |	for (byte i = 0; i < hole_count; i++) {
 2209|       |		zindex += p * graph[positions[i]];
 2210|       |		p *= (nat) (positions[i] & 3 ? operation_count : 5);
 2211|       |	}
 2212|       |
 2213|       |	atomic_store_explicit(&head, zindex, memory_order_relaxed);
 2214|       |
 2215|       |
 2216|       |
 2217|       |
 2218|       |
 2219|       |
 2220|       |
 2221|       |
 2222|       |
 2223|       |
 2224|       |
 2225|       |
 2226|       |
 2227|       |
 2228|       |const nat h = atomic_fetch_add_explicit(&head, job_size, memory_order_relaxed);
 2229|       |	if (h >= space_size) goto terminate_thread;
 2230|       |
 2231|       |// if (range_end >= space_size) range_end = space_size - 1; // is this neccessary now?...
 2232|       |
 2233|       |
 2234|       |
 2235|       |
 2236|       |
 2237|       |
 2238|       |
 2239|       |if (h >= space_size) {
 2240|       |			snprintf(output_string, 4096, "info: [all jobs allocated to threads. waiting for them to finish.]\n");
 2241|       |			print(output_filename, 4096, output_string);
 2242|       |			break;
 2243|       |		}
 2244|       |
 2245|       |
 2246|       |
 2247|       |
 2248|       |
 2249|       |*/
 2250|       |
 2251|       |
 2252|       |// memset(timeout, 0, operation_count * sizeof(nat));
 2253|       |
 2254|       |
 2255|       |
 2256|       |		/*for (nat i = 0; i < operation_count; i++) {
 2257|       |			if (timeout[i] >= execution_limit >> 1) return pm_ot; 
 2258|       |			timeout[i]++;
 2259|       |		}
 2260|       |		timeout[ip] = 0;*/
 2261|       |
 2262|       |
 2263|       |
 2264|       |			/*if (bout_length == 1) {
 2265|       |				H1_counter++;
 2266|       |				if (H1_counter >= max_consecutive_h1_bouts) return pm_h1; 
 2267|       |			} else H1_counter = 0;*/
 2268|       |

