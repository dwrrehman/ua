[bits done]
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 printing counts: bit_count = 0
    counts[0] =          0
    counts[1] =         12
    counts[2] =          3
    counts[3] =          6
    counts[4] =          0
    counts[5] =         12
    counts[6] =         12
    counts[7] =          2
    counts[8] =          2
    counts[9] =         12
    counts[10] =         12
    counts[11] =          3
    counts[12] =         12
    counts[13] =         12
    counts[14] =         13
    counts[15] =          2
    counts[16] =          3
    counts[17] =         12
    counts[18] =         12
    counts[19] =          3
    counts[20] =         12
    counts[21] =         12
    counts[22] =         12
    counts[23] =          2
    counts[24] =          3
    counts[25] =         12
    counts[26] =         12
[counts done]
threshold = 1
printing bits: real_bit_count = 6421026784
    bits[0] =          0
    bits[1] =          0
    bits[2] =          0
    bits[3] =          1
    bits[4] =          1
    bits[5] =          0
    bits[6] =          0
    bits[7] =          1
    bits[8] =          1
    bits[9] =          0
    bits[10] =          1
    bits[11] =          1
    bits[12] =          1
    bits[13] =          0
    bits[14] =          0
    bits[15] =          1
    bits[16] =          1
    bits[17] =          0
    bits[18] =          1
    bits[19] =          1
    bits[20] =          1
    bits[21] =          0
    bits[22] =          0
    bits[23] =          1
[bits done]


                received: data = 0x9D, control = 0xCA

control transfer successful, breaking...
received: (4) {0xDE, 0xAD, 0xFA, 0x9D, }
root@raspberrypi:/home/dwrr/client# 




the problem here, was that we were expecting   counts[3] to be 12,  and    counts[4] shouldnt exist at all, 


		that shift over by 1 caused the rest of the bits to be failed lol 





		so yeah, we need to account for bit shiftings by accident,    which i think we can do  


				if we just like, delay between each byte, for a EVEN LONGER period of time, 

					which will cause us to haveeee to synchronize the sequences of 8 bits with each other, 


			basically, we will use the same majority rules  thing for them, 




	so that if there is a bit error,    it will only be localized,  unlikely taht we will actuallyyy get the wrong data because of it lol 






	but yeah, that bit shift cost us the entire byte technically lol 


interesting



i didnt exactly account for that situationnnnnn lolololol    but we can, easily i think 


	sohuldnt be that bad

	