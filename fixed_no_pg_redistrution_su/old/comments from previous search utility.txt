202501131.034612:







/*


	const double seconds = difftime(time_end.tv_sec, time_begin.tv_sec);
	char time_begin_dt[32] = {0}, time_end_dt[32] = {0};
	strftime(time_end_dt,   32, "1%Y%m%d%u.%H%M%S", localtime(&time_end.tv_sec));
	strftime(time_begin_dt, 32, "1%Y%m%d%u.%H%M%S", localtime(&time_begin.tv_sec));

	snprintf(output_string, 4096,
		"using [D=%hhu, R=%hhu]:"
		"\n\tthread_count=%llu"
		"\n\tjob_count_per_core=%llu"		
		"\n\tdisplay_rate=%llu"
		"\n\tstage1_execution_limit=%llu"
		"\n\tstage2_execution_limit=%llu"
		"\n\tarray_size=%llu"
		"\n\n"
		"\n\t""searched [%hhu:%hhu] zvs"
		"\n\tusing %llu threads, each with %llu jobs"
		"\n\tin %10.2lfs [%s:%s],"	
		"\n\n", 

		D, R,  thread_count, job_count_per_core, 
		display_rate,  stage1_execution_limit, 
		stage2_execution_limit,   array_size, 
		D, R, thread_count,  job_count_per_core, 
		seconds,  time_begin_dt,  time_end_dt
	);
	print(output_filename, 4096, output_string);

	snprintf(output_string, 4096, "\npm counts:\n");
	print(output_filename, 4096, output_string);
	for (nat i = 0; i < pm_count; i++) {
		if (i and not (i % 2)) {
			snprintf(output_string, 4096, "\n");
			print(output_filename, 4096, output_string);
		}
		snprintf(output_string, 4096, "%6s: %-8lld\t\t", pm_spelling[i], counts[i]);
		print(output_filename, 4096, output_string);
	}
	snprintf(output_string, 4096, "\n[done_pm]\n");
	print(output_filename, 4096, output_string);






}



*/



































































/*
	for (byte index = graph_count - 4; index >= 20; index -= 4) {
		if (graph[index] != two and graph[index] != six) {       // for now
			at = index; 
			counts[pm_ga_26dol]++; 
			// puts(pm_spelling[pm_ga_26dol]); 
			goto bad; 
		}  
	}
*/


/*


ttp4  (aka ttp3)    pruning table  for creating    ct ega    source code:


------------------------------------------------------------------------

H	[1]                                   ..... [pm_ns0]


H	2 >     [1]                           ..... [pm_ns0]
H	2 >     2 >     [1]                   ..... [pm_ns0]
H	2 >     2 >     2 >     [1]           ..... [pm_ns0]
H	2 >     2 >     2 >     [5]           ..... [pm_pco]
H	2 >     2 >     3 >     [5]           ..... [pm_zr5]
H	2 >     2 >     [5]                   ..... [pm_pco]

H	2 >     2 >     6 =     [1]           ..... [pm_ns0]
H	2 >     2 >     6 =     [5]           ..... [pm_pco]
H	2 >     2 >     6 =     [6]           ..... [pm_zr6]
H	2 >     3 =     1 >     [1]           ..... [pm_ns0]
H	2 >     3 =     1 >     [5]           ..... [pm_pco]
H	2 >     3 =     2 >     [5]           ..... [pm_zr5]
H	2 >     3 =     3 <     [5]           ..... [pm_zr5]
H	2 >     3 =     [5]                   ..... [pm_zr5]
H	2 >     3 =     6 <     [5]           ..... [pm_zr5]
H	2 >     3 =     6 <     [6]           ..... [pm_zr6]
H	2 >     [5]                           ..... [pm_pco]

H	2 >     6 =     [1]                   ..... [pm_ns0]
H	2 >     6 =     2 >     [1]           ..... [pm_ns0]
H	2 >     6 =     2 >     [5]           ..... [pm_pco]
H	2 >     6 =     3 <     [5]           ..... [pm_zr5]
H	2 >     6 =     3 <     [6]           ..... [pm_zr6]
H	2 >     6 =     [5]                   ..... [pm_pco]
H	2 >     6 =     [6]                   ..... [pm_zr6]





	3 <     1 =     [1]                   ..... [pm_ns0]
	3 <     1 =     2 >     [1]           ..... [pm_ns0]
	3 <     1 =     2 >     [5]           ..... [pm_pco]
	3 <     1 =     3 <     [6]           ..... [pm_zr6]
	3 <     1 =     [5]                   ..... [pm_pco]
	3 <     1 =     [6]                   ..... [pm_zr6]
	3 <     2 =     1 >     [1]           ..... [pm_ns0]
	3 <     2 =     1 >     [5]           ..... [pm_pco]
	3 <     2 =     2 >     [5]           ..... [pm_zr5]
	3 <     2 =     3 <     [5]           ..... [pm_zr5]
	3 <     2 =     [5]                   ..... [pm_zr5]
	3 <     2 =     6 <     [5]           ..... [pm_zr5]
	3 <     2 =     6 <     [6]           ..... [pm_zr6]
	3 <     3 <     1 =     [1]           ..... [pm_ns0]
	3 <     3 <     1 =     [5]           ..... [pm_pco]
	3 <     3 <     1 =     [6]           ..... [pm_zr6]
	3 <     3 <     2 <     [5]           ..... [pm_zr5]
	3 <     3 <     3 <     [5]           ..... [pm_zr5]
	3 <     3 <     3 <     [6]           ..... [pm_zr6]
	3 <     3 <     [5]                   ..... [pm_zr5]
	3 <     3 <     [6]                   ..... [pm_zr6]
	3 <     [5]                           ..... [pm_zr5]
	3 <     [6]                           ..... [pm_zr6]

H	[5]                                   ..... [pm_pco]
H	[6]                                   ..... [pm_zr6]

*/











/*

		if (graph[4 * graph[4 * o + 1]] == five) continue;
		if (graph[4 * graph[4 * o + 1]] == six) continue;

		const byte eq_case = graph[4 * graph[4 * o + 1] + 3];

		if (graph[4 * graph[4 * o + 1]] == one) {
			if (at > 4 * graph[4 * o + 1] + 3) { at = 4 * graph[4 * o + 1] + 3; if (at == 3) goto exit_ega; }
			
			if (graph[4 * eq_case] == six) continue;

			if (graph[4 * eq_case] == two) {
				if (at > 4 * eq_case + 2) at = 4 * eq_case + 2;
				if (graph[4 * graph[4 * eq_case + 2]] == one) continue;
				if (graph[4 * graph[4 * eq_case + 2]] == five) continue;
			}

			if (graph[4 * eq_case] == three) {
				if (at > 4 * eq_case + 1) at = 4 * eq_case + 1;
				if (graph[4 * graph[4 * eq_case + 1]] == six) continue;
				if (graph[4 * graph[4 * eq_case + 1]] == one) continue;
			}
	
		} else if (graph[4 * graph[4 * o + 1]] == two) {
			if (at > 4 * graph[4 * o + 1] + 3) at = 4 * graph[4 * o + 1] + 3;

			if (graph[4 * eq_case] == five) continue; 
			if (graph[4 * eq_case] == three) continue;

			if (graph[4 * eq_case] == one) {
				if (at > 4 * eq_case + 2) { at = 4 * eq_case + 2; if (at == 3) goto exit_ega; }
				if (graph[4 * graph[4 * eq_case + 2]] == one) continue;
			}

			if (graph[4 * eq_case] == two) {
				if (at > 4 * eq_case + 2) at = 4 * eq_case + 2;
				if (graph[4 * graph[4 * eq_case + 2]] == three) continue;
				if (graph[4 * graph[4 * eq_case + 2]] == five) continue;
			}
		

		*/




	
	/*
	at = graph_count;
	for (byte o = 0; o < operation_count; o++) {
		if (graph[4 * o] != three) continue;

		if (at > 4 * o + 1) at = 4 * o + 1;

		if (graph[4 * graph[4 * o + 1]] == five) continue;
		if (graph[4 * graph[4 * o + 1]] == six) continue;

		const byte eq_case = graph[4 * graph[4 * o + 1] + 3];

		if (graph[4 * graph[4 * o + 1]] == one) {
			if (at > 4 * graph[4 * o + 1] + 3) { at = 4 * graph[4 * o + 1] + 3; if (at == 3) goto exit_ega; }
			
			if (graph[4 * eq_case] == six) continue;

			if (graph[4 * eq_case] == two) {
				if (at > 4 * eq_case + 2) at = 4 * eq_case + 2;
				if (graph[4 * graph[4 * eq_case + 2]] == one) continue;
				if (graph[4 * graph[4 * eq_case + 2]] == five) continue;
			}

			if (graph[4 * eq_case] == three) {
				if (at > 4 * eq_case + 1) at = 4 * eq_case + 1;
				if (graph[4 * graph[4 * eq_case + 1]] == six) continue;
				if (graph[4 * graph[4 * eq_case + 1]] == one) continue;
			}
	
		} else if (graph[4 * graph[4 * o + 1]] == two) {
			if (at > 4 * graph[4 * o + 1] + 3) at = 4 * graph[4 * o + 1] + 3;

			if (graph[4 * eq_case] == five) continue; 
			if (graph[4 * eq_case] == three) continue;

			if (graph[4 * eq_case] == one) {
				if (at > 4 * eq_case + 2) { at = 4 * eq_case + 2; if (at == 3) goto exit_ega; }
				if (graph[4 * graph[4 * eq_case + 2]] == one) continue;
			}

			if (graph[4 * eq_case] == two) {
				if (at > 4 * eq_case + 2) at = 4 * eq_case + 2;
				if (graph[4 * graph[4 * eq_case + 2]] == three) continue;
				if (graph[4 * graph[4 * eq_case + 2]] == five) continue;
			}
		}
		goto exit_ega;
	}
	goto bad;
exit_ega:;
	*/














		//if (graph[4 * index] == one and graph[4 * index + 2] == index) {       // removed this ga pm too.
		//	at = 4 * index + 2; goto bad; 
		//}







//printf("trying combination: [index = %u, i = %hhu]\n", j, i);



// print_graph_raw(graph); printf("at = %hhu\n", at); getchar(); 




// const nat debug = not memcmp(graph, (byte[]) {0, 1, 1, 2, 1 ,1 ,2 ,0 ,2 ,1 ,3 ,4 ,3 ,0 ,2 ,0 ,4 ,0 ,0 ,1}, graph_count);



// 01121120213430204001
// 01121120213430204001





/*

if (debug) {
			printf("origin = %hhu, pm = %s\n", o, pm_spelling[pm]);
			getchar();
		}
*/




















/*


with ct-ega:
=-------------

PRUNED:  origin = 0, z = 00411120202432244302 ... at = 1
PRUNED:  origin = 0, z = 01411423234030444302 ... at = 1
PRUNED:  origin = 0, z = 01041040200032444302 ... at = 3
PRUNED:  origin = 0, z = 00011022241134444302 ... at = 6
su: 0 space:
	 good    12 zv
	 bad     16188009 zv
	 exg_bad 4197998 zv
	 execution_limit = 10000000000
	 array_size = 1000000
	 in    1450.00s [1202410222.201110:1202410222.203520]


pm counts:
z_is_good: 12      		 pm_ga: 0       		
pm_zr5: 1501823 		pm_zr6: 1204877 		
pm_pco: 813413  		pm_per: 402525  		
pm_ns0: 773358  		pm_oer: 216     		
pm_r0i: 22278   		pm_r1i: 452     		
 pm_h0: 2413552 		 pm_h1: 45      		
pm_erw: 3909    		pm_rmv: 4922    		
pm_imv: 156     		 pm_pt: 1254482 		[done]
D_general_search_utility: 

1202410222.201418_73a9b4c20a9a67e11f19ea375e5fd0d4_z.txt


02421020210331024001 2 1202410222.201418
02421020211331024001 2 1202410222.201452
02421020212331024001 2 1202410222.201526
02421020210331124001 2 1202410222.201605
02421020211331124001 2 1202410222.201639
02421020212331124001 2 1202410222.201713
02421020210331224001 2 1202410222.201755
02421020211331224001 2 1202410222.201829
02421020212331224001 2 1202410222.201903
02421020210331424001 2 1202410222.201954
02421020211331424001 2 1202410222.202028
02421020212331424001 2 1202410222.202102






without ct-ega: (but with rt-ega)
=-------------

su: 0 space:
	 good    50 zv
	 bad     17948095 zv
	 exg_bad 6510145 zv
	 execution_limit = 10000000000
	 array_size = 1000000
	 in    2973.00s [1202410222.183934:1202410222.192907]


pm counts:
z_is_good: 50      		 pm_ga: 0       		
pm_zr5: 2164468 		pm_zr6: 1842803 		
pm_pco: 2022018 		pm_per: 521677  		
pm_ns0: 2283862 		pm_oer: 258     		
pm_r0i: 34582   		pm_r1i: 816     		
 pm_h0: 2838664 		 pm_h1: 76      		
pm_erw: 6229    		pm_rmv: 6112    		
pm_imv: 286     		 pm_pt: 1298489 		[done]
D_general_search_utility: 







*/












		/*if (e == index) {  
			at = 4 * index + 3; goto bad; 
		}




if (graph[4 * index] == five and l == g and l == e and graph[4 * e] == one) { 
			// when we duplicate a five, this is not quite sound. 
			if (index == five) { at = 4 * index + 1; goto bad; } 
			if (e == one) { at = 4 * index; goto bad; }
			at = 4 * (index < e ? index : e); goto bad; 
		}

		if (graph[4 * index] == five and l == g and l == e and graph[4 * e] == three) {
			if (index == five) { at = 4 * index + 1; goto bad; } 
			if (e == three) { at = 4 * index; goto bad; }
			at = 4 * (index < e ? index : e); goto bad; 
		}













	at = graph_count;
	for (byte o = 0; o < operation_count; o++) {
		const byte t0 = 4 * o;
		if (graph[t0] == one) continue;
		else if (graph[t0] == five) continue;
		else if (graph[t0] == six) continue;
		else if (graph[t0] == two) {  if (at > t0 + 2) at = t0 + 2;
			const byte t1 = 4 * graph[t0 + 2];
			if (graph[t1] == one) continue;
			else if (graph[t1] == five) continue;
			else if (graph[t1] == two) {  if (at > t1 + 2) at = t1 + 2;
				const byte t2 = 4 * graph[t1 + 2];
				if (graph[t2] == one) continue;
				else if (graph[t2] == five) continue;
				else if (graph[t2] == two) {  if (at > t2 + 2) at = t2 + 2;
					const byte t3 = 4 * graph[t2 + 2];
					if (graph[t3] == one) continue;
					if (graph[t3] == five) continue;
				}
				else if (graph[t2] == three) { if (at > t2 + 2) at = t2 + 2;
					const byte t3 = 4 * graph[t2 + 2];
					if (graph[t3] == five) continue;
				}
				else if (graph[t2] == six) { if (at > t2 + 3) at = t2 + 3;
					const byte t3 = 4 * graph[t2 + 3];
					if (graph[t3] == one) continue;
					if (graph[t3] == five) continue;
					if (graph[t3] == six) continue;
				}
			}
			if (graph[t1] == three) {  if (at > t1 + 3) at = t1 + 3;
				const byte t2 = 4 * graph[t1 + 3];
				if (graph[t2] == five) continue;
				else if (graph[t2] == one) {  if (at > t2 + 2) at = t2 + 2;
					const byte t3 = 4 * graph[t2 + 2];
					if (graph[t3] == one) continue;
					if (graph[t3] == five) continue;
				}
				else if (graph[t2] == two) {  if (at > t2 + 2) at = t2 + 2;
					const byte t3 = 4 * graph[t2 + 2];
					if (graph[t3] == five) continue;
				}
				else if (graph[t2] == three) { if (at > t2 + 1) at = t2 + 1;
					const byte t3 = 4 * graph[t2 + 1];
					if (graph[t3] == five) continue;
				}
				else if (graph[t2] == six) { if (at > t2 + 1) at = t2 + 1;
					const byte t3 = 4 * graph[t2 + 1];
					if (graph[t3] == five) continue;
					if (graph[t3] == six) continue;
				}
			}
			else if (graph[t1] == six) { if (at > t1 + 3) at = t1 + 3;
				const byte t2 = 4 * graph[t1 + 3];
				if (graph[t2] == one) continue;
				else if (graph[t2] == five) continue;
				else if (graph[t2] == six) continue;
				else if (graph[t2] == two) {   if (at > t2 + 2) at = t2 + 2;
					const byte t3 = 4 * graph[t2 + 2];
					if (graph[t3] == one) continue;
					if (graph[t3] == five) continue;
				} 
				else if (graph[t2] == three) {   if (at > t2 + 1) at = t2 + 1;
					const byte t3 = 4 * graph[t2 + 1];
					if (graph[t3] == five) continue;
					if (graph[t3] == six) continue;
				}
			}
		} 
		else if (graph[t0] == three) { if (at > t0 + 1) at = t0 + 1;
			const byte t1 = 4 * graph[t0 + 2];
			if (graph[t1] == five) continue;
			else if (graph[t1] == six) continue;
			else if (graph[t1] == one) { if (at > t1 + 3) at = t1 + 3;
				const byte t2 = 4 * graph[t1 + 3];
				if (graph[t2] == one) continue;
				else if (graph[t2] == five) continue;
				else if (graph[t2] == six) continue;
				else if (graph[t2] == two) { if (at > t2 + 2) at = t2 + 2;
					const byte t3 = 4 * graph[t2 + 2];
					if (graph[t3] == one) continue;
					if (graph[t3] == five) continue;
				}
				if (graph[t2] == three) { if (at > t2 + 1) at = t2 + 1;
					const byte t3 = 4 * graph[t2 + 1];
					if (graph[t3] == six) continue;
				}
			}
			else if (graph[t1] == two) { if (at > t1 + 3) at = t1 + 3;
				const byte t2 = 4 * graph[t1 + 3];

				if (graph[t2] == five) continue;

				else if (graph[t2] == one) {  if (at > t2 + 2) at = t2 + 2;
					const byte t3 = 4 * graph[t2 + 2];
					if (graph[t3] == one) continue;
					if (graph[t3] == five) continue;
				}
				else if (graph[t2] == two) { if (at > t2 + 2) at = t2 + 2;
					const byte t3 = 4 * graph[t2 + 2];
					if (graph[t3] == five) continue;
				}
				else if (graph[t2] == three) { if (at > t2 + 1) at = t2 + 1;
					const byte t3 = 4 * graph[t2 + 1];
					if (graph[t3] == five) continue;
				}
			}
			else if (graph[t1] == three) { if (at > t1 + 1) at = t1 + 1;
				const byte t2 = 4 * graph[t1 + 1];

				if (graph[t2] == five) continue;
				else if (graph[t2] == six) continue;

				else if (graph[t2] == one) {  if (at > t2 + 3) at = t2 + 3;
					const byte t3 = 4 * graph[t2 + 3];
					if (graph[t3] == one) continue;
					if (graph[t3] == five) continue;
					if (graph[t3] == six) continue;
				}
				else if (graph[t2] == two) { if (at > t2 + 1) at = t2 + 1;
					const byte t3 = 4 * graph[t2 + 1];
					if (graph[t3] == five) continue;
				}
				else if (graph[t2] == three) { if (at > t2 + 1) at = t2 + 1;
					const byte t3 = 4 * graph[t2 + 1];
					if (graph[t3] == five) continue;
					if (graph[t3] == six) continue;
				}
			}
		}
		goto exit_ega;
	}

	// printf("CT-EGA ga prune: at = %hhu, goto bad;\n", at);

	goto bad;
exit_ega:;








*/





			//if (pointer_incr_timeout >= 100000) return pm_pt;
			//else pointer_incr_timeout++;






//if (pointer_incr_timeout >= 100000) return pm_pt;
			//else pointer_incr_timeout++;






 //pm_pt,//"pm_pt",






// pointer_incr_timeout = 0,


/*

if ((at < 20 and at % 4 == 0) or at == 5 or at == 1) {
		printf("internal programming error: at was set to the value of %hhu, which is not an valid hole\n", at);
	}












					if (index == source) { at = 4 * index + offset; goto bad; } 


					if (dest == destination) { at = 4 * index; goto bad; }

					at = 4 * (index < dest ? index : dest); goto bad; 














		if (graph[4 * index] == two and g == index) {  
			at = 4 * index + 2 * (index == two); goto bad; 
		}

		if (graph[4 * index] == three and l == index) {  
			at = 4 * index + 1 * (index == three); goto bad; 
		}













	{const byte pairs[3 * 3] = {
			three, three, pm_ga_ndi,
			five, one, pm_ga_pco,
			five, five, pm_ga_zr5,
		};

		for (nat i = 0; i < 3 * 3; i += 3) {
			const byte source = pairs[i + 1], destination = pairs[i + 0];
			if (graph[4 * index] == source) {
				for (byte offset = 1; offset < 4; offset++) {
					const byte middle = graph[4 * index + offset];
					if (graph[4 * middle] != two and graph[4 * middle] != six) continue;
					for (byte offset2 = 1; offset2 < 4; offset2++) {
						const byte dest = graph[4 * middle + offset2];
						if (graph[4 * dest] != destination) continue;
						at = graph_count;
						if (4 * index < 20 and at > 4 * index + offset) at = 4 * index + offset;
						if (4 * middle < 20 and at > 4 * middle + offset2) at = 4 * middle + offset2;
						if (4 * index >= 20 and at > 4 * index) at = 4 * index;
						if (4 * middle >= 20 and at > 4 * middle) at = 4 * middle;
						if (4 * dest >= 20 and at > 4 * dest) at = 4 * dest;
						counts[pairs[i + 2]]++;
						// puts(pm_spelling[pairs[i + 2]]);
						goto bad;
					}
				}
			} 
		} }








*/


/*


		if (graph[4 * index] == one and l == g and g == e and graph[4 * l] == one) {
			at = graph_count;
			if (index < 5 and at > 4 * index + 1) at = 4 * index + 1;
			if (index >= 5 and at > 4 * index) at = 4 * index;
			if (l >= 5 and at > 4 * l) at = 4 * l;
			counts[pm_ga_ns0]++;
			//puts(pm_spelling[pm_ga_ns0]);
			goto bad;
		}













if (pointer == 1) {
				if (last_mcal_op == three) {
					R1I_counter++;
					if (R1I_counter >= max_consecutive_s0_incr) return pm_r1i;
				} else R1I_counter = 0;
			}

			if (pointer == 2) {
				if (last_mcal_op == three) {
					R2I_counter++;
					if (R2I_counter >= max_consecutive_s0_incr) return pm_r2i;
				} else R2I_counter = 0;
			}

			if (pointer == 3) {
				if (last_mcal_op == three) {
					R3I_counter++;
					if (R3I_counter >= max_consecutive_s0_incr) return pm_r3i;
				} else R3I_counter = 0;
			}








*/









/*
			if (pointer == 1) {
				if (last_mcal_op == three) {
					R1I_counter++;
					if (R1I_counter >= max_consecutive_s0_incr) return pm_r1i;
				} else R1I_counter = 0;
			}

			if (pointer == 2) {
				if (last_mcal_op == three) {
					R2I_counter++;
					if (R2I_counter >= max_consecutive_s0_incr) return pm_r2i;
				} else R2I_counter = 0;
			}

			if (pointer == 3) {
				if (last_mcal_op == three) {
					R3I_counter++;
					if (R3I_counter >= max_consecutive_s0_incr) return pm_r3i;
				} else R3I_counter = 0;
			}
*/











/*if (graph[4 * index] == six and l != g) { //  
			counts[pm_ga_6g]++;
			// puts(pm_spelling[pm_ga_6g]);
			at = 4 * index + 2 * (index == six); goto bad;
		}*/






/*




static nat execute_graph_starting_at(byte origin, byte* graph, nat* array, byte* zskip_at) {

	const nat n = array_size;
	array[0] = 0; 
	array[n] = 0;

	nat 	xw = 0,  pointer = 0,  
		bout_length = 0, 
		RMV_value = 0, 
		IMV_value = 0,
		OER_er_at = 0,
		ERW_counter = 0,
		walk_ia_counter = 0;

	byte	H0_counter = 0,  H1_counter = 0, 
		OER_counter = 0, RMV_counter = 0, 
		IMV_counter = 0, CSM_counter = 0;
	
	byte ip = origin;
	byte last_mcal_op = 255;
	nat did_ier_at = (nat)~0;

#define max_rsi_count 20
	byte rsi_counter[max_rsi_count] = {0};


	for (nat e = 0; e < execution_limit; e++) {

		if (e and not (e & ((1 << 28) - 1))) {
			printf("taking a significant amount of time on e = %llu, z = ", e); 
			print_graph_raw(graph); puts(""); 
		}

		const byte I = ip * 4, op = graph[I];

		if (op == one) {
			if (pointer == n) { 
				puts("FEA condition violated by a z value: "); 
				print_graph_raw(graph); 
				puts(""); 
				abort(); 
			}
  
			if (not array[pointer]) return pm_ns0; 
			if (last_mcal_op == one)  H0_counter = 0;

			if (pointer < max_rsi_count) { 
				if (last_mcal_op == three) {
					rsi_counter[pointer]++;
					if (rsi_counter[pointer] >= max_consecutive_s0_incr) return pm_rsi;
				} else rsi_counter[pointer] = 0;
			}

			bout_length++;
			pointer++;

			if (pointer > xw and pointer < n) { 
				xw = pointer; 
				array[pointer] = 0; 
			}
		}

		else if (op == five) {
			if (last_mcal_op != three) return pm_pco;
			if (not pointer) return pm_zr5; 
			
			if (pointer == OER_er_at or pointer == OER_er_at + 1) {
				OER_counter++;
				if (OER_counter >= max_oer_repetions) return pm_oer;
			} else { OER_er_at = pointer; OER_counter = 0; }
			
			CSM_counter = 0;
			RMV_value = (nat) -1;
			RMV_counter = 0;
			for (nat i = 0; i < xw; i++) {
				if (array[i] < 8) CSM_counter++; else CSM_counter = 0;
				if (CSM_counter > max_consecutive_small_modnats) return pm_csm;
				if (array[i] == RMV_value) RMV_counter++; else { RMV_value = array[i]; RMV_counter = 0; }
				if (RMV_counter >= max_rmv_modnat_repetions) return pm_rmv;
			}

			IMV_value = (nat) -1;
			IMV_counter = 0;
			for (nat i = 0; i < xw; i++) {
				if (array[i] == IMV_value + 1) { IMV_counter++; IMV_value++; } else { IMV_value = array[i]; IMV_counter = 0; }
				if (IMV_counter >= max_imv_modnat_repetions) return pm_imv;
			}

			IMV_value = (nat) -1;
			IMV_counter = 0;
			for (nat i = 0; i < xw; i += 2) { // note the "i += 2".
				if (array[i] == IMV_value + 1) { IMV_counter++; IMV_value++; } else { IMV_value = array[i]; IMV_counter = 0; }
				if (IMV_counter >= 2 * max_imv_modnat_repetions) return pm_imv;
			}

			if (walk_ia_counter < (e < 1000000 ? 3 : 6)) {
				ERW_counter++;
				if (ERW_counter >= max_erw_count) return pm_erw;
			} else ERW_counter = 0;

			walk_ia_counter = 0;
			did_ier_at = pointer;
			pointer = 0;
		}

		else if (op == two) {
			array[n]++;
		}

		else if (op == six) {  
			if (not array[n]) return pm_zr6;
			array[n] = 0;
		}
		else if (op == three) {
			if (last_mcal_op == three) return pm_ndi;

			if (last_mcal_op == one) {
				H0_counter++;
				if (H0_counter >= max_consecutive_h0_bouts) return pm_h0; 
			}

			if (bout_length == 2) {
				H1_counter++;
				if (H1_counter >= max_consecutive_h1_bouts) return pm_h1; 
			} else H1_counter = 0;

			if (did_ier_at != (nat) ~0) {
				if (pointer >= did_ier_at) return pm_per; 
				did_ier_at = (nat) ~0;
			}

			walk_ia_counter++;
			bout_length = 0;
			array[pointer]++;
		}
		if (op == three or op == one or op == five) last_mcal_op = op;
		byte state = 0;
		if (array[n] < array[pointer]) state = 1;
		if (array[n] > array[pointer]) state = 2;
		if (array[n] == array[pointer]) state = 3;
		if (*zskip_at > I + state) *zskip_at = I + state;
		ip = graph[I + state];
	}
	return z_is_good;
}






*/







		/*

		{const byte pairs[3 * 3] = {
			three, three, pm_ga_ndi,
			five, one, pm_ga_pco,
			five, five, pm_ga_zr5,
		};

		for (nat i = 0; i < 3 * 3; i += 3) {
			const byte source = pairs[i + 1], destination = pairs[i + 0];
			if (graph[4 * index] == source) {
				for (byte offset = 1; offset < 4; offset++) {
					const byte middle = graph[4 * index + offset];
					if (graph[4 * middle] != two and graph[4 * middle] != six) continue;
					for (byte offset2 = 1; offset2 < 4; offset2++) {
						const byte dest = graph[4 * middle + offset2];
						if (graph[4 * dest] != destination) continue;
						at = graph_count;
						if (4 * index < 20 and at > 4 * index + offset) at = 4 * index + offset;
						if (4 * middle < 20 and at > 4 * middle + offset2) at = 4 * middle + offset2;
						if (4 * index >= 20 and at > 4 * index) at = 4 * index;
						if (4 * middle >= 20 and at > 4 * middle) at = 4 * middle;
						if (4 * dest >= 20 and at > 4 * dest) at = 4 * dest;
						counts[pairs[i + 2]]++;
						// puts(pm_spelling[pairs[i + 2]]);
						goto bad;
					}
				}
			} 
		} }
		*/










	srand((unsigned) time(0));


	byte graph[graph_count] = {0};
	memcpy(graph, partial_graph, sizeof partial_graph);


	... z index math ... 



	struct timeval time_begin = {0};
	gettimeofday(&time_begin, NULL);


	... start up threads ...
	

	


static pthread_t* threads = calloc(...);














/*




	goto init;
loop:
	if (graph[pointer] < ((pointer % 4) ? operation_count - 1 : 4)) goto increment;
	if (pointer < graph_count - 1) goto reset_;
	goto done;

increment:
	graph[pointer]++;
init:  	pointer = 1;

	u16 was_utilized = 0;
	byte at = 1;

	const byte debug = not (display_counter & ((1 << display_rate) - 1));
	if (debug) display_counter = 1; else display_counter++;

	if (debug) {
		printf("GA trying: z = "); print_graph_raw(graph); puts(""); fflush(stdout);
		display_counter = 1;
	}

	for (byte index = 20; index < graph_count; index += 4) {	
		if (index < graph_count - 4 and graph[index] > graph[index + 4]) { 
			at = index + 4; 
			counts[pm_ga_sdol]++; 
			// puts(pm_spelling[pm_ga_sdol]); 
			goto bad; 
		} 
	}

	for (byte index = operation_count; index--;) { 

		const byte l = graph[4 * index + 1], g = graph[4 * index + 2], e = graph[4 * index + 3];

		if (graph[4 * index] == six and graph[4 * e] == one) {
			at = graph_count;
			if (editable(4 * index + 3) and at > 4 * index + 3) at = 4 * index + 3;
			if (editable(4 * index) and at > 4 * index) at = 4 * index;
			if (editable(4 * e) and at > 4 * e) at = 4 * e;
			counts[pm_ga_ns0]++;
			//puts(pm_spelling[pm_ga_ns0]);
			goto bad;
		}
 
		if (graph[4 * index] == six and graph[4 * e] == five) {
			at = graph_count;
			if (editable(4 * index + 3) and at > 4 * index + 3) at = 4 * index + 3;
			if (editable(4 * index) and at > 4 * index) at = 4 * index;
			if (editable(4 * e) and at > 4 * e) at = 4 * e;
			counts[pm_ga_ns0]++;
			//puts(pm_spelling[pm_ga_ns0]);
			goto bad;
		}

		{const byte pairs[3 * 7] = {
			three, three, pm_ga_ndi,
			five, one,  pm_ga_pco,
			five, five, pm_ga_zr5,

			six, six, pm_ga_zr6,
			two, two, pm_ga_sndi,
			two, six, pm_ga_sn1,
			six, two, pm_ga_snco,
		};
		for (nat i = 0; i < 7 * 3; i += 3) {
			const byte source = pairs[i + 1], destination = pairs[i + 0];
			if (graph[4 * index] == source) {
				for (byte offset = 1; offset < 4; offset++) {
					const byte dest = graph[4 * index + offset];
					if (graph[4 * dest] != destination) continue;
					at = graph_count;
					if (editable(4 * index + offset) and at > 4 * index + offset) at = 4 * index + offset;
					if (editable(4 * index) and at > 4 * index) at = 4 * index;
					if (editable(4 * dest) and at > 4 * dest) at = 4 * dest;
					if (at == graph_count) continue;
					counts[pairs[i + 2]]++;
					//puts(pm_spelling[pairs[i + 2]]);
					goto bad;
				}
			} 
		}}
	
		if (l != index) was_utilized |= 1 << l;
		if (g != index) was_utilized |= 1 << g;
		if (e != index) was_utilized |= 1 << e;

		const byte j = 4 * index;
		for (byte i = graph_count - 4; i >= 20 and j < i; i -= 4) {
			if (not memcmp(graph + i, graph + j, 4)) { 
				at = j + (j < 20); 
				counts[pm_ga_rdo]++; 
				// puts("pm_ga_rdo"); 
				goto bad;
			}
		}
	}

	for (byte index = 0; index < operation_count; index++) {
		if (not ((was_utilized >> index) & 1)) { 
			at = 1;
			counts[pm_ga_uo]++; 
			//puts("pm_ga_uo"); 
			goto bad; 
		} 
	}

	for (byte index = operation_count; index--;) { 
		if (graph[4 * index] == six and graph[4 * index + 2] != 4) {
			at = graph_count;
			if (editable(4 * index + 2) and at > 4 * index + 2) at = 4 * index + 2;
			if (editable(4 * index) and at > 4 * index) at = 4 * index;
			counts[pm_ga_6g]++;
			//puts(pm_spelling[pm_ga_6g]);
			goto bad;
		}
	}

	byte origin = 0;
	at = execute_graph(graph, array, &origin, counts);

	if (debug) {
		printf("\033[%dm%s:  origin = %hhu, z = ", at ? 31 : 32, at ? "PRUNED" : " FOUND", at); 
		print_graph_raw(graph); 
		printf(" ... at = %hhu\033[0m\n", at);
		fflush(stdout);
		display_counter = 1;
	}

	if (not at) {
		printf("\033[32m  ---> GOOD: origin = %hhu, z = ", origin); 
		print_graph_raw(graph); 
		printf("\033[0m\n");
		fflush(stdout);

		append_to_file(filename, sizeof filename, graph, origin);
		usleep(100000);
		good_count++;
		goto loop;
	} else exg_bad_count++;

bad:	bad_count++;
	if (noneditable(at)) {
		printf("internal programming error: at was set to the value of %hhu, which is not an valid hole\n", at);
		abort();
	}
	for (byte i = 1; i < at; i++) if (editable(i)) graph[i] = 0;
	pointer = at; goto loop;
reset_:
	graph[pointer] = 0; 
	do pointer++; while (noneditable(pointer));
	goto loop;
done:;
	struct timeval time_end = {0};
	gettimeofday(&time_end, NULL);

	printf("final graph state: ");
	print_graph_raw(graph); 
	puts("");









*/












